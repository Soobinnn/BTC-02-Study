# 이더리움 월렛
이더리움 월렛(Ethereum Wallet)은 이더리움(ETH)을 쉽게 받고, 보낼 수 있으며, 이더리움 계정과 상호 작용할 수 있는 애플리케이션

## 암호화폐 지갑이란?

암호화폐 지갑은 블록체인 네트워크와 상호 작용하는 수단 중 하나

지갑의 종류는 다양하며 소프트웨어, 하드웨어, 종이 지갑이라는 세 그룹으로 나눌 수 있음.

작동 메커니즘에 따라 핫 또는 콜드 월렛[지갑]이라고 할 수 있다.

대부분의 암호화폐 지갑 공급 업체들은 소프트웨어에 기반을 두고 있으며, 이는 하드웨어 지갑보다 간편함.

그러나 보통 하드웨어 지갑을 선택하는 것이 가장 안전한 편.

한편, 종이 지갑은 종이에 프린트된 “지갑"으로 구성되는데, 이는 다소 구식이고 또 신뢰하기 힘든 것으로 여겨짐.

## 암호화폐 지갑은 어떻게 작동하나요?

암호화폐 지갑은 실제로 암호화폐를 저장하지 않습니다. 대신, 이는 블록체인과 상호 작용할 수 있는 수단을 제공.
-> 이러한 지갑은 블록체인 트랜잭션을 통해 암호화폐를 주고받을 때 필요한 정보를 생성할 수 있다.

이러한 정보는 하나 또는 그 이상의 공개 키와 개인 키 쌍으로 구성됨.

지갑에는 또한 공개 키와 개인 키를 기반으로 생성되는 영숫자 식별자인 공개 주소가 포함되어 있다.

이러한 주소는 기본적으로 코인이 전송될 수 있는 블록체인상의 특정한 “위치"
이는 자금을 전달받기 위해 공개 주소를 공유할 수 있음을 의미.
\* 개인 키는 누구에게도 절대 공개해서는 안 됨.

어떤 지갑을 사용하든지 개인 키를 통해 암호화폐에 접근할 수 있다.

따라서 컴퓨터나 스마트폰이 손상되더라도 해당 개인 키(또는 시드 문구)가 있는 한, 다른 장치를 통해 여전히 자금에 접근할 수 있다.
\* 한 가지 알아둘 것은 코인들이 실제로 블록체인을 빠져 나가는 것이 결코 아니며, 단지 한 주소에서 다른 주소로 전송된다는 것

### 서명 (Signature)

디지털 서명(Digital Signature)은 메시지나 디지털 문서의 진위성과 무결성을 검증하는 데 사용하는 수학적 메커니즘.

디지털 서명은 일반적인 손으로 쓴 서명이나 도장의 디지털 버전이지만, 보다 복잡하며 보안이 우수
디지털 서명은 디지털 통신에서 변조 및 사칭 문제를 해결하기 위한 것으로, 전자 문서, 거래, 메시지의 출처, 신원 및 상태에 대한 보증을 제공할 수도 있다.
디지털 서명은 메시지나 문서에 첨부된 코드입니다. 이 코드는 생성된 이후부터 수신자에게 전송되기까지의 과정에서 메시지의 내용이 변조되었는지 확인할 수 있도록 해줌.

### 공개키 암호화 방식 (Public Key Cryptography, PKC)
공개 키와 비밀 키로 구성된 한 쌍의 키를 사용한 암호화 방식
두 키는 타원곡선 알고리즘(Elliptic Curve Algorithm, ECDSA)를 사용하여 생성됩니다. 
공개 키로 암호화된 데이터는 해당 개인 키로 복호화 할 수 있습니다.
따라서 공개 키는 외부에 공개하고, 비밀 키는 기밀로 유지

\* 반대로 비밀 키로 암호화된 데이터를 공개 키로 해독하는 방식
이러한 방법은 중요한 데이터를 암호화하는 데에는 적합하지 않다.

공개 키는 누구에게나 공개되어 있기 때문에 누구나 쉽게 복호화를 할 수 있기 때문
그러나 데이터의 내용을 숨기는 것이 아니라, 디지털 서명을 하여 데이터의 무결성과 진위성을 검증해야 할 때는 비밀 키로 암호화하는 방식을 사용

### 디지털 서명의 동작 방식
디지털 서명은 크게 해싱, 서명, 검증 세 단계로 나뉨.

1. 해싱
원본 데이터를 해싱함.
원본 데이터를 해싱하는 것은 필수적인 것은 아님. 해싱하지 않은 원본 데이터에 개인 키로 서명을 할 수도 있기 때문이다.
그러나 해싱을 함으로써 고정된 길이의 값을 비교하는 것이 무결성을 검증하는데 훨씬 간편하기 때문에 일반적으로 데이터를 해싱함.

2. 서명
공개 키 암호화 방식을 사용해 해싱된 데이터에 서명
서명을 하는 방식은 다양하지만, 일반적으로 송신자의 개인 키로 해시값을 암호화
-> 이 암호화된 결과값이 바로 디지털 서명

디지털 서명은 개인 키로 암호화 되었기 때문에 공개 키로 복호화 할 수 있으며, 정상적으로 복호화 될 경우 원본 데이터의 해시값이 나오게 됨.
서명이 완료되면 송신자는 원본 데이터와 디지털 서명, 송신자의 공개 키를 함께 전송

3. 검증
수신자는 송신자의 공개 키를 가지고 디지털 서명을 복호화 

두 해시값을 비교하여 만약 해시값이 맞다면, 데이터가 정상적으로 송신자에 의해 서명된 것임을 확인

### 디지털 서명의 특징

1. 데이터 무결성 수신자는 메시지가 전송되는 동안 위변조가 일어나지 않았음을 검증할 수 있습니다. 
   만약 송신자의 공개 키로 디지털 서명을 복호화 한 값이 원본 데이터를 해싱한 값과 다른 경우, 해당 송신자의 개인 키로 암호화된 서명이 아니거나, 원본 데이터가 훼손되었을 수 있다.

2. 진위성 송신자의 개인 키가 안전하게 보관되었다는 전제 하에, 수신자는 디지털 서명이 송신자에 의해 생성되었음을 확인할 수 있다.

3. 부인 방지 송신자의 개인 키가 안전하게 보관되었다는 전제 하에, 서명이 생성되고 나면 이 서명이 송신자에 의해 서명되었다는 사실을 부정할 수 없다.

### 디지털 서명 시스템의 필요조건

1. 알고리즘
    디지털 서명 체계에서 사용되는 알고리즘은 수준이 중요합니다. 신뢰할 수 있고, 널리 사용되어 그 안전성이 입증된 해시 함수와 암호화 알고리즘을 사용해야함.

2. 구현
    디지털 서명 방식은 데이터의 무결성 및 진위성과 직결되기 때문에 결점 없는 시스템을 구현하는 것 역시 중요

3. 개인키
    개인 키가 유출되거나 손상될 경우, 진위성과 부인 방지 속성이 무효화됨.
    -> 특히 암호화폐에서 개인 키를 잃어버릴 경우 재정적 손실로 이어짐.

## 공개 키 암호 방식과 대칭 키 암호 방식

### 대칭 키 암호 방식

#### 대칭 키 암호 방식의 동작원리

여러 사용자 사이에 공유된 단일 키를 기반으로 합니다. 하나의 키로 원본 데이터를 암호화하며, 동일한 키를 사용해 복호화

대칭 키 암호 방식에서는 **블록 암호 방식**이나 **스트림 암호 방식**을 사용

- 블록 암호 방식
: 데이터를 미리 정해둔 사이즈로 잘라 청크(chunk) 단위로 그룹화하고, 각 블록을 비밀키로 암호화

- 스트림 암호 방식
: 원본 데이터의 길이와 같은 키로 키 스트림(Key Stream)을 생성하고, 원본 데이터와 키 스트림을 XOR 연산하여 암호화합니다. 
나중에 복호화 할때도 암호화된 값과 키 스트림을 XOR 연산을 하면 원본 데이터가 나옴

> XOR 연산 : 두 임의의 값 A, B가 모두 참이거나 거짓일때는 거짓, 둘 중 하나만 참일 경우에는 참을 출력하는 연산

#### 대칭 키 암호방식의 장단점

- 장점
1. 비대칭 키 암호 방식에 비해 비교적 간결하기 때문에 네트워크나 CPU의 오버헤드가 적고 빠르게 작동
2. 대칭 키 암호 방식은 키의 길이가 길어질수록 무차별 대입 공격을 통한 복호화 난이도가 기하급수적으로 증가하기 때문에, 단순히 키의 길이를 늘림으로써 보안을 높일 수 있다

- 단점
1. 데이터 암호화 및 복호화에 사용하는 키를 관리하는 것이 어렵다는 것
    -> 허가받지 않은 제삼자가 해당 키를 가지게 된다면 해당 키를 사용한 모든 데이터의 보안에 위협
       이러한 위험을 예방하기 위해 대부분의 웹 프로토콜은 대칭 암호화와 공개 키 암호 방식을 혼합하여 키를 보호
       example) TLS(Transport Layer Security)의 암호화 프로토콜로, TLS에서는 공개 키 암호 방식을 사용해 대칭 키 암호 방식에 사용할 키를 공유
       * SSL이 표준화 되어 바뀐이름이 TLS, (TLS1.0은 SSL 3.0을 계승)


### 공개 키 암호 방식 (비대칭 키 암호 방식)

#### 공개 키 암호 방식의 동작원리
공개 키 암호 방식은 대칭 키 암호 방식과 다르게 단일 키가 아닌 공개 키와 비밀 키를 사용

공개 키로 암호화 한 데이터는 비밀 키로 복호화 할 수 있어야 하기 때문에, 두 키는 알고리즘에 의해 수학적으로 연결되어 있음.
\* 오늘날 사용되는 공개 키 암호 방식 알고리즘은 RSA 암호 방식. RSA 암호 방식은 두 개의 소수를 곱하여 얻어낸 계수를 사용해 공개 키와 비밀 키를 생성
-> 공개 키 암호 방식은 디지털 서명 방식에 사용되기도 함.

디지털 서명 방식은 기본적으로 메시지와 메시지를 해싱한 값을 함께 보내는 것을 의미.
공개 키 암호 방식은 이 해싱한 값을 암호화 및 복호화 하여 데이터의 무결성과 진위성을 검증할 수 있도록 해줌.

#### 공개 키 암호 방식의 장단점

- 장점
1. 공개 키 암호 방식은 기존의 대칭 키 암호 방식이 가졌던 키 노출 문제를 해결하여 컴퓨터 보안을 강화
   -> 데이터의 무결성을 확인하는 데 사용

- 단점
1. 암호화 및 복호화의 수학적 계산이 매우 복잡하기 때문에, 대량의 데이터를 처리할 경우 오버헤드가 발생하여 속도가 느려질 수 있다.

2. 대칭 키 암호 방식과 마찬가지로, 개인 키가 안전하지 않은 공간에 노출되는 경우, 대응하는 공개 키로 암호화된 모든 데이터의 보안이 위협받음.

### 블록체인에서의 공개 키 암호 방식
공개 키 암호 방식은 트랜잭션을 검증하는 디지털 서명 방식으로 사용.

새로운 암호 화폐 지갑이 설정될 때, 비밀 키가 먼저 생성되며, 이 비밀 키를 기반으로 공개 키가 생성

사용자의 지갑은 이 공개 키를 해싱한 값으로 생성되며, 이 지갑은 일종의 계좌번호의 역할을 하여 다른 사람들과 공유할 수 있다.

반면, 비밀 키는 디지털 서명을 생성하고 트랜잭션을 검증할 때 사용되기 때문에 사용자가 각별히 유의하여 보관해야함.

\* 비트코인과 이더리움은 트랜잭션 검증을 위해 **ECDSA(타원곡선 디지털서명 알고리즘, Elliptic Curve Digital Signature Algorithm) 알고리즘**을 사용해 디지털 서명을 구현


#### 공개 키 암호방식과 대칭 키 암호방식의 비교
- 차이점
1. 키의 길이
대칭 키 암호화 알고리즘 : 길이 임의로 지정. 보안 수준에 따라 128 비트나 256 비트로 설정됨.
공개 키 암호화 알고리즘 : 공개 키와 비밀 키가 수학적으로 한 쌍을 이루어야 하기 때문에 수학적 패턴 -> 어떠한 패턴을 가졌다는 것은 곧 공격자에 의해 패턴이 간파될 수 있다는 것을 의미
-> 따라서 공개 키 암호 방식 알고리즘은 대칭 키 방식과 동등한 수준의 보안을 제공하기 위해 훨씬 더 긴 키를 사용
\* 128비트의 대칭 키 - 2,048 비트의 공개 키가 비슷한 수준의 보안을 제공

2. 연산 속도
대칭 키 암호 방식 : 블록 암호화나 스트림 암호화 모두 연산이 단순하기 때문에 연산 속도가 빠름. 
-> 대용량 데이터를 전송해야 할 때 많이 사용
공개 키 암호화 방식 : 복잡한 수학적 연산을 수행해야 하기 때문에 비교적 속도가 느리며, 키 길이가 길기 때문에 훨씬 더 많은 연산 능력을 필요
-> 주로 데이터 전송에 앞서 안전한 통신 채널을 인증하고 구축하기 위한 소규모 트랜잭션(ex. TLS)에 많이 사용

3. 보안
대칭 키 암호 방식 : 단일한 비밀 키를 공유해야 하기 때문에, 키 노출 시 보안 위협이 큼
공개 키 암호 방식 : 암호화 할 때 공개 키를 사용하고, 복호화 할 때는 개인 키를 사용하여 이러한 문제를 해결

4. 알고리즘
대칭 키 암호화 방식 알고리즘 : RC4, AES, DES, 3DES 등
공개 키 암호화 방식 알고리즘 :  RSA, 디피-헬먼, ECC 등

## HD 지갑 (Hierarchical Deterministic Wallet)
HD 지갑(Hierarchical Deterministic Wallet, 계층적 결정 지갑)으로,
하나의 시드 키(seed key)를 사용하여 여러 주소를 생성할 수 있는 암호화폐 지갑.

HD 지갑은 트리 형태로, 하나의 부모 키가 여러 개의 연속된 자식 키를 만들고, 이 자식 키는 다시 여러 개의 손자 키를 만들어내는 방식으로 여러 개의 주소를 생성

### 비결정적 지갑과 결정적 지갑

기본적으로 암호화폐를 사용할 때는 개인 정보 보호를 위해 암호화폐 주소는 재사용하지 않는 것이 가장 바람직하다.
극단적으로는 매 트랜잭션마다 새로운 비밀 키를 생성할 수 있다.
그러나 기존의 지갑은 새로운 비밀 키를 무작위로 추출해 보관해야 합니다. 이런 식으로 매번 무작위로 비밀 키를 생성하다보면, 실수로 지갑 데이터를 분실하는 경우 해당 비밀 키에 저장된 코인과 해당 비밀 키로 생성한 스마트 컨트랙트에 접근하지 못하게 됨.
따라서 지갑 데이터를 자주 백업해야 하는 불편함이 있다. 
이렇게 매번 비밀 키를 무작위로 생성하는 방식의 지갑을 **비결정적 지갑**

이러한 비결정적 지갑의 불편함을 해결하는 방식의 지갑이 바로 **결정적 지갑**
결정적 지갑은 하나의 시드에서 하나의 시드 키를 가지고 있음.
이 시드 키는 비밀 키를 만들기 위한 난수이다.
비밀 키는 시드 키를 인덱스 또는 다른 데이터와 결합하여 만듬

이 시드 키는 자신으로부터 만들어진 비밀 키를 복구할 수 있다.
이러한 특징 때문에 시드 키로부터 만들어지는 모든 비밀 키는 그 값이 미리 정해져 있다고 볼 수 있다.
따라서 시드 키를 이용한 지갑 방식을 결정적 지갑(deterministic wallet)이라고 함.
-> 결정적 지갑을 사용하면 하나의 시드 키만 알고 있어도 시드 키에서 파생된 모든 비밀 키를 알 수 있기 때문에 모든 비밀 키를 관리할 필요 없이, 시드 키 하나만을 관리하면 됨.

### BIP 32
BIP32에서는 결정적 지갑을 이진 트리 형식으로 계층화하여 끝없이 비밀 키를 생성할 수 있는 구조를 제안
-> HD 지갑은 BIP32에서 제안한 지갑 구조를 프로그래밍화 한 것
\* HD 지갑은 BIP32에서 처음 제안되었고, BIP39, BIP44 등 여러 버전이 존재

### HD 지갑의 구조
HD 지갑은 시드 키로부터 마스터 키를 하나 생성함.
그리고 마스터 키로부터 자식 키를 생성. 
자식 키의 갯수는 2^32개(4,294,967,295개) 생성할 수 있으며, 각 자식 키는 0부터 2^32-1까지 인덱스가 붙게 됨.

자식 키는 일반 자식 키(Normal Child Key)와 단절 자식 키(Hardened Child Key)로 나뉨.
일반 자식 키 : 0~2^31-1번째 인덱스까지
단절 자식 키 : 2^31~2^32-1번째 인덱스까지

일반 자식 키는 부모 키의 공개 키를 통해 자신의 공개 키를 구할 수 있다.
단절 자식 키는 부모의 비밀 키를 알아야 자신의 공개 키를 구할 수 있다.
부모 키와 연관 없어 보이는 공개 키를 만들기 위해서는 단절 자식 키를 사용

\* 자식 키를 표기할 때는 m(마스터 키)/n번째 자식/m번째 손자 방식으로 표기
example) 마스터 키에서 나온 3번째 자식으로부터 나온 20번째 키를 가리킬 때는 m/3/20이 되며,  단절 자식 키는 m/3/20'으로 표기

### DRBG
일반적으로 컴퓨터가 만들어내는 난수는 예측이 가능한 가짜 난수이기 때문에 안전하지 않다.
따라서 컴퓨터로 만들어낸 난수를 해싱한 값을 사용하는데, 이는 해시 알고리즘이 공개되지 않는 이상 해싱한 값은 완전한 난수이기 때문이다.
이렇게 컴퓨터로 만든 난수를 해시함수를 통해 진짜 난수로 만드는 알고리즘을 DRBG(Deterministic Random Bits Generate)이라 함.
\* HD 지갑에서는 시드 키를 생성할 때 DRBG를 사용

### HMAC-SHA512
HD 지갑에서는 부모 키를 통해 자식 키를 확인할 수 있어야 하기 때문에, HMAC 방식을 사용하여 자식 키를 만듬.
HMAC-SHA512는 부모의 키 값을 패딩하여 XOR 연산을 하고, 그 결과값을 해싱합니다. 마스터 키는 시드 키에 HMAC-SHA512를 연산한 결과값

### BIP 44
여러 계정이 여러 목적에 맞게 여러 지갑을 사용할 수 있는 HD 지갑 구조를 제안
BIP44에는 다섯 가지 트리 레벨로 구성.

1. 목적: 항상 44로 설정됨
2. 코인 종류: 어떤 종류의 코인인지 나타냅니다. SLIP0044 문서에 각 코인의 종류와 할당된 번호가 있음.
3. 계정: 사용자는 자신의 지갑을 논리적 계정으로 나눌 수 있다. \* 가령 m/44'/0'/0'과 m/44'/0'/1'은 하나의 HD 지갑에 2개의 비트코인 계정이 있는 것
4. 잔액 계정 여부: 비트코인의 잔액 계정 여부. 하위 트리에 있는 값이 입금 주소인지 잔액 주소인지 표기하며, 잔액 주소이면 1을 넣고, 아니면 0을 넣습니다. 
    이더리움에서는 UTXO가 아닌 어카운트 기반이기 때문에 늘 잔액 주소가 필요없어 늘 이 값이 0임.
5. 사용 가능한 주소: 입금 주소나 잔액 주소를 표기
example)
```
M/44'/60'/0'/0/2 : 이더리움 계정에 대한 세 번째 수신 공개키
M/44'/0'/3'/1/14 : 4번째 비트코인 계정의 15번째 주소 변경 공개키
m/44'/2'/0'/0/1 : 트랜잭션 서명을 위한 라이트코인 메인 계정의 두 번째 개인 키
```

## 니모닉 지갑(Mnemonic Wallet)
니모닉(Mnemonic)이란 결정적 지갑에서 난수를 12개의 영단어로 인코딩한 영단어 그룹으로, BIP39에서 제안

기존의 시드 키는 숫자와 문자로 구성된 난수이기 때문에 사용자가 기억하기 어려웠지만, 니모닉 코드 단어의 경우 사용자가 기억하고 사용하기 쉬운 형태로 구성되어 있다는 장점

```
시드 키: 8979644bfb6b6206792bdd6a071b3a00daebfb84ac5e3d81fa8c87a8012b04be060765762d4540ff10788959a84dec51667f34b0380e66be373d0ab2c62f8f94
니모닉: endless convince patrol calm apology scene client jungle fitness blind grass pause
```

### 나모닉 코드 단어
니모닉 코드 단어는 결정적 지갑의 난수를 인코딩한 영단어 시퀀스

결정적 지갑을 사용하는 지갑 어플리케이션에서는 사용자가 지갑을 생성하면, 해당 지갑에서 만든 난수로부터 영단어 시퀀스를 만들어 사용자에게 제공함.
그리고 이 단어 시퀀스에서 시드 키를 생성

사용자가 이 단어 시퀀스를 기억하고 있으면 호환되는 다른 지갑 어플리케이션에서도 시드 키 및 파생된 모든 비밀 키를 복구할 수 있다.

16진수의 난수로 구성된 시드 키와 비교했을 때, 니모닉 단어는 사용자에게 익숙한 영단어 목록이기 때문에 사용자가 쉽게 읽을 수 있고, 사용자가 받아적기 쉽다는 장점
예를 들어, 시드 키에서 숫자 하나가 바뀌어서 지갑에 접근하지 못하는 경우, 우리는 시드 키의 어떤 부분이 잘못되었는지 찾기가 어려울 것이다.

```
잘못 입력한 시드 키: 8979644bfb6b6206792bdd6a071b3a00daebfb84ac5e3d81fa8c87a8012b04be060765762d4540ff10788959a84dec51667f34b0370e66be373d0ab2c62f8f94

정상적인 시드 키: 8979644bfb6b6206792bdd6a071b3a00daebfb84ac5e3d81fa8c87a8012b04be060765762d4540ff10788959a84dec51667f34b03**8**0e66be373d0ab2c62f8f94
```
반면 니모닉 코드 단어는 잘못 입력된 곳을 찾기가 쉬움
```
잘못 입력한 니모닉: endless convince patrol calm apoiogy scene client jungle fitness blind grass pause
정상적인 니모닉: endless convince patrol calm apology scene client jungle fitness blind grass pause
```

\* 나모닉 코드는 사용자에게 편리함을 제공

### 나모닉 단어 생성
니모닉 단어를 생성하는 순서는 다음과 같다

1. 128bit 또는 256bit 길이의 난수를 생성

2. 난수를 SHA-256 알고리즘으로 해싱하고, 해시값에서 (시드 키의 길이) / 32 만큼을 떼어냅니다. 
    가령, 난수의 길이가 128bit라면, 해시값에서 128 / 32 인 4bit를 앞에서부터 떼어내 체크섬으로 만듬.

3. 체크섬을 난수의 뒤에 붙입니다.

4. 체크섬을 붙인 난수를 11bit 단위로 잘라냅니다.

5. 각 11bit의 단어를 사전에 정의된 단어로 치환합니다.

6. 각 11bit의 순서를 유지하여 일련의 니모닉 코드를 만듭니다.
 
\* 체크섬(checksum): 어떤 일련의 데이터에 오류가 존재하는 지 확인하기 위한 검사용 데이터

### 시드 생성
BIP39에서는 니모닉 단어로부터 시드 키를 생성함.
여기서 생성된 시드는 결정적 지갑을 구축하고 비밀 키를 생성하는 데 사용됩니다. 시드 키를 생성할 때는 PBKDF2 함수를 사용

\*PBKDF2는 키 스트레칭 함수의 한 종류

#### 솔팅(salting)과 키 스트레칭

해시 함수는 동일한 입력에 대해서는 항상 같은 값을 출력합니다. 따라서 다른 사용자와 비밀번호가 같은 경우, 해시값도 같을 것이다.

해커들은 자주 쓰이는 비밀번호와 비밀번호의 해시값을 가지고 있다가(이를 레인보우 테이블이라고 함), 
레인보우 테이블에 있는 해시값과 데이터베이스에 저장된 해싱된 비밀번호를 비교하는 레인보우 공격을 할 수도 있다.
-> 또한 해시 함수는 연산 속도가 빠르기 때문에, 무차별 대입 공격을 당할 수도 있다.

따라서, 해시값을 비교해도 원본 비밀번호를 알 수 없도록 해야 함.

솔팅(salting)은 원본 데이터에 임의의 문자열인 솔트(salt)를 추가하여 해싱하는 방식
솔팅 방식으로 비밀번호를 암호화하여 데이터베이스에 보관하면, 해커가 솔트가 무엇인지 알지 못하는 이상 레인보우 테이블의 해시값과 데이터베이스의 해시값을 비교해도 
원본 비밀번호를 알 수 없다.

키 스트레칭(key stretching)은 이러한 솔팅 방식을 여러번 반복하는 것
-> 솔팅의 결과값을 다시 솔트함수의 입력값으로 하여 다시 솔팅을 하고, 이 과정을 반복
사용자가 입력한 비밀번호는 예측하기 쉬운 경우가 많은데, 키 스트레칭은 이러한 예측을 더욱 어렵게 해줌.

#### BIP39에서의 시드 생성 방법
BIP39에서는 키 스트레칭 함수인 PBKDF2 함수를 사용

1. PBKDF2 함수에 니모닉 코드를 입력합니다.
2. PBKDF2에 솔트를 입력합니다. 솔트는 문자열 "Mnemonic"에 임의의 암호문을 붙인 형태
3. PBKDF2 함수는 입력받은 니모닉 코드와 솔트로 HMAC-SHA512로 2048번 해싱하여 512 bit의 값을 만들어내며, 이 값이 시드 키가 됨.

### 다양한 월렛
브레인 월렛(Brain Wallet)은 비밀 키를 랜덤하게 생성하지 않고, 일련의 단어 목록이나 문장(seed phrase)를 사용해 비밀 키를 만드는 지갑
따라서 비밀 키를 만들 때 사용한 단어 목록이나 문장을 기억하고 있으면 언제든지 비밀 키를 복구할 수 있기 때문에 저장 방식이 간편하다는 장점
또한 사용자에게 익숙한 문장을 시드로 삼는 경우 어딘가에 기록하지 않고도 사용할 수 있기 때문에 안전함.

그러나 사용자가 비밀 키를 생성할 때 사용한 단어 목록이나 문장을 잊어버리는 경우, 해당 비밀 키에 있는 자산에 영영 접근할 수 없게 됨.

또한 인간이 만들어내는 문장은 컴퓨터가 만들어내는 난수에 비해 임의성(randomness)가 부족하기 때문에, 무차별 대입 공격을 통해 비밀 키를 해킹당할 수도 있다.

따라서 오늘날 브레인 월렛은 잘 사용되지 않음.

### 스마트 컨트랙트 월렛
스마트 컨트랙트 월렛은 비밀 키가 아닌 스마트 컨트랙트로 관리하는 이더리움 지갑을 의미

스마트 컨트랙트 월렛은 기존의 단일 키를 사용하는 월렛보다 **더 높은 수준의 보안, 유연성, 편의성을 제공**

사용자는 **멀티 시그 트랜잭션, 일일 송금 제한, 긴급 계정 동결, 안전한 계정 복구 등 고급 기능을 사용**

일반적인 이더리움 EOA 계정만 관리하기 때문에 기능상 제한이 있다. 
그러나 스마트 컨트랙트 월렛의 경우, CA의 기능을 활용할 수 있다.
즉, 누가 어떤 조건에서 자산에 접근할 수 있는지를 알려주는 프로그래밍화된 규칙을 통해 자산을 관리할 수 있다.

많이 사용되는 스마트 컨트랙트 월렛에는 다음과 같은 것들이 있다.

- InstaDApp
:  다양한 금융 프로토콜을 통홥하여 이더리움 및 기타 암호화폐를 사용한 대출 시스템을 제공
->  또한 토큰을 유동성 풀에 추가하여 수익을 얻을 수 있는 유니스왑과도 통합

- Zerion
: Zerion은 다양한 프로토콜과 대출과 같은 코어 금융 서비스를 제공합니다
> 또한 유니스왑을 사용한 토큰 교환, 뱅커와 유니스왑 유동성 풀을 사용한 수익화를 지원

- Metamask
: 암호화폐 보안 뿐만 아니라 다양한 DApp과 상호작용 할 수 있도록 지원
예를 들어, Metamask를 지원하는 DApp에서 토큰을 구입하거나 대여, 또는 수익화하거나, NFT를 교환하고 게임을 하는 등 다양한 활동을 할 수 있음.

#### 멀티 시그 월렛
멀티 시그 월렛(multi-signature wallet)은 스마트 컨트랙트 월렛의 한 종류로, 
멀티시그(multi-sig)를 통해서만 송금이 가능하다는 특징

기존의 핫 월렛과 콜드 월렛은 하나의 개인 키를 사용하기 때문에, , 이 단일 키가 노출될 경우 탈취자가 해당 개인 키에 연결된 자산에 쉽게 접근할 수 있다는 단점이 있다.

이러한 단점을 보완하기 위한 것이 바로 멀티 시그 월렛.

멀티 시그 월렛은 하나의 지갑에 N명의 사용자가 지갑에 대한 소유 권한을 가지고, 해당 지갑에서 트랜잭션을 만들기 위해서는 N명 중 k명이 트랜잭션에 서명을 해야함.

이더리움 상에서 구현할 때는, 멀티 시그 월렛을 위한 스마트 컨트랙트를 만들어 N명 중 k명이 서명해야 컨트랙트를 이행한다는 서명 제한 룰을 추가하고, 
실제로 k명이 멀티 시그 월렛 컨트랙트에 트랜잭션을 보내야함.

멀티 시그 월렛은 일반 지갑에 비해 보안이 우수하다는 장점이 있으며, 실수로 송금이 일어나는 경우를 방지할 수도 있다.
N명 중 1명이 실수로 송금 트랜잭션을 생성해도, 나머지 N-1명이 서명을 하지 않으면 트랜잭션이 완료되지 않기 때문.

- 단점
그러나 멀티 시그 월렛은 스마트 컨트랙트 상에서 구현되기 때문에 사용성이 부족 
가령, 대부분의 암호화폐 거래소에서는 일반 지갑 간에 이루어진 트랜잭션만 처리하기 때문에 멀티 시그 월렛에서 일어난 트랜잭션을 인식하지 못하기도 함.

또한 멀티 시그 월렛은 스마트 컨트랙트 상에서 구현되기 때문에 컨트랙트 코드의 오류로 인해 문제가 발생할 수 있다. 
example) 2017년 멀티 시그 월렛을 사용하는 패리티(Parity)에서는 스마트 컨트랙트 버그를 이용한 해킹 사례가 있었다.

#### 멀티 시그 월렛의 특징

다중서명 지갑은 두 명 혹은 그 이상의 사용자가 공동으로 문서에 서명할 수 있게 하는 특별한 디지털 서명이다.
그러므로 다중서명은 다수의 고유한 서명들의 조합으로 만들어 짐.

다중서명 기술은 암호 화폐 세계에 존재해 왔으나, 그 원리는 비트코인이 탄생하기 훨씬 전부터 있었다.
암호 화폐에서, 이 기술은 2012년에 처음으로 비트코인 주소에 적용되었으며, 일 년 후 다중서명 지갑의 탄생으로 이어졌습니다. 다중서명 주소는 다양한 상황에서 사용될 수 있으나, 대부분 보안 문제와 연관되어 있다.

기본적으로, 다중서명 주소에 보관된 자금에는 두 개 혹은 그 이상의 서명이 있어야만 접근할 수 있습니다. 
그러므로, 다중서명 지갑을 이용하는 것은, 사용자들이 자신들의 자금에 대한 보안을 한 층 더 높일 수 있게 합니다. 

#### 단일 키 vs 다중 서명
보통 비트코인은 단일 키 주소에 저장되며, 이는 해당 개인 키를 소유한 누구나 자금에 접근할 수 있음을 의미함.
트랜잭션에 서명하기 위해서는 하나의 키만 있으면 되며, 개인 키를 소유한 이는 누구나, 다른 이의 동의 없이 마음껏 코인을 전송할 수 있다.

단일 키 주소를 관리하는 것은 다중서명 주소 보다 빠르고 쉽지만, 특별히 보안과 관련해 몇 가지 문제점들이 있다. 
하나의 키를 소유함으로써, 자금은 한 가지 측면에 대한 공격 실패에 대해서만 안전하며, 
이것이 사이버 범죄자들이 암호 화폐 사용자들의 자금을 탈취하기 위한 새로운 피싱 기술들을 지속적으로 개발하는 이유다.

게다가, 단일 키 주소는 암호 화폐와 관련된 기업들에게 최상의 선택지가 아니다. 

다중서명 지갑은 이러한 두 문제에 잠정적인 해결책을 제공합니다. 
단일 키와 다르게, 다중서명 주소에 보관된 자금은 다중서명이 제공(서로 다른 개인 키를 사용하여 생성되는)될 때에만 이동시킬 수 있습니다.

다중서명 주소가 구성된 방식에 따라, 이는 다양한 키 조합을 요구할 수 있습니다. 2/3이 가장 일반적, 
두 개의 서명이 있으면, 삼중 서명 주소의 자금에 접근할 수 있는 것입니다. 그러나 2/2, 3/3, 3/4와 같은 다양한 용례들이 있다.

##### 보안 증진
다중서명 지갑을 사용함으로써, 사용자는 개인 키를 잃어버리거나 도난당했을 때 발생할 수 있는 문제들을 방지.
키 하나가 유출된다 해도, 자금은 안전

##### 이중 인증(Two-factor authentication)
두 개의 키가 필요한 다중서명 지갑을 만듦으로써, 앨리스는 자금에 접근하는 이중 인증 메커니즘을 만들 수 있다.

이는 두 키를 모두 소유한 자만이 트랜잭션을 발생시킬 수 있게 합니다.

2/3 설정이나 백업 코드를 포함하고 있는 제3자의 이중 인증 서비스를 이용하는 것이 더 안전할 것이다.
-> 거래소의 거래 계정의 경우, 구글 인증(Google Authenticator)을 사용하는 것이 강력히 권고됨.


##### 에스크로 거래

2/3 다중서명 지갑을 만드는 것은, 두 당사자(앨리스와 밥)간의 에스크로 거래를 가능하게 하며, 문제가 발생할 경우 상호 신뢰할 수 있는 중재자로서 제3자(찰리)를 포함

중재자인 찰리는 분쟁이 있을 때만 개입하면 되는데, 어느 순간에 서명을 위해 앨리스나 밥이 제공한 키를 사용할 것인지 자신의 판단에 따라 결정하게 됨.

#### 의사결정

이사회는 다중서명 지갑을 사용해 회사 자금에 접근하는 것을 통제할 수도 있습니다. 
예를 들어, 4/6 지갑을 설정함으로써, 각 이사진들이 하나의 키를 소유하게 되면, 어떤 단독 이사도 자금을 오용할 수 없게 됨. 
그러므로, 다수결에 의해 합의된 결정만이 실행될 수 있다.

#### 단점

다중서명 지갑은 다양한 문제의 좋은 해결책이지만, 몇 가지 위험과 한계가 있음을 염두에 두는 것이 중요. 
특별히 제3자 제공자에 의존하지 않고, 다중서명 주소를 설정하려면 어느 정도의 기술적 지식이 필요

또한, 블록체인과 다중서명 주소는 모두 상대적으로 새로운 것이기에, 만약 문제가 발생할 경우 법적 상환을 요청하기 어려울 수 있다. 
다수의 키 보유자가 있는 공유 지갑에 예치된 자금에는 법적 관리인이 없다.

## 지갑의 사용 용도에 따른 종류

### 핫 월렛 (Hot wallets)

핫 월렛(Hot Wallet)은 온라인에 연결되어 있는 암호화폐 지갑
핫 월렛은 인터넷 상에 연결되어 있고 개인 키가 서버에 저장되어 있기 때문에 사용자가 쉽게 접근할 수 있으며, 실시간으로 거래를 할 수 있다.

일반적으로 우리가 알고 있는 빗썸, 업비트와 같은 암호화폐 거래소를 생각해보면, 별도의 개인 키를 입력하지 않고 아이디와 비밀번호만 입력해도 거래소를 이용할 수 있다.
이는 모든 암호화폐 자산을 사용자 개인이 보유하고 관리하는 대신, 암호화폐 거래소가 사용자 정보를 대신 저장하고 관리해주고 있기 때문이다.

크롬 브라우저에서 사용하는 이더리움 플러그인인 메타마스크(MetaMask) 역시 핫 월렛의 일종. 
크롬 브라우저에 설치를 하는 지갑으로, 메타마스크가 사용자 정보를 보관하고, 사용자는 비밀번호만 입력하면 암호화폐를 사용할 수 있다

#### 핫월렛의 보안적 문제
핫 월렛은 온라인에 연결되어야 작동하며, 온라인 연동이 없을 경우 동작하지 않는다.
-> 그러나 인터넷에 연결되어 있다는 것 자체로는 보안에 취약하다는 것을 의미

### 콜드 월렛 (Cold wallets)
콜드 월렛은 지갑의 개인 키를 오프라인으로 보관하는 지갑을 의미.
-> 개인 키를 USB나 카드에 보관하기 때문에 '하드웨어 월렛(hardware wallet)'이라고도 부름

콜드 월렛으로 거래를 하기 위해서는 먼저 오프라인 상에서 트랜잭션을 생성하고, 이 트랜잭션을 온라인에 입력해야 함.
이 때문에 바로 거래를 할 수 있는 핫 월렛에 비해서는 번거롭다는 단점이 있지만, 
트랜잭션을 온라인에 입력할 때를 제외하고는 오프라인 상태이기 때문에, 해킹의 위험이 비교적 적다

이러한 콜드 월렛의 보안 때문에 많은 암호화폐 거래소에서는 일부 자산을 콜드 월렛에 보관합니다. 
2019년 빗썸은 약 350억 원 규모의 암호화폐를 탈취 당했습니다. 
당시 빗썸이 가장 먼저 한 일은 보유하고 있던 자산을 전부 콜드 월렛으로 이동시켜 보관한 것
-> 일단 코인을 오프라인으로 옮기면 해킹 가능성이 거의 없기 때문

또한 하드 월렛을 잃어버리더라도 복구 문구(recovery phrase)만 알고 있으면 소유권을 증명할 수 있다.

핫 월렛과 콜드 월렛은 각각의 장단점이 있기 때문에, 필요에 따라 지갑을 선택할 수 있습니다. 
**만약 암호화폐 거래를 자주 하는 경우,** 접근성이 편리한 **핫 월렛**을 사용하는 것이 바람직할 것

반대로, **암호 화폐를 안전하게 보관하는 것**이 주 목적인 경우에는 **콜드 월렛**을 사용하는 것이 좋다.

### 스마트 컨트랙트 지갑
스마트컨트랙트 기능을 통해 고유한 능력을 가진 지갑입니다. 사용자를 위한 추가 보안 및 복구 기능을 사용할 수 있다.

#### 특징

- 2단계 인증
인증 앱 및/또는 기본 지갑 솔루션을 통해 추가 보안 기능을 제공

- ATM과 같은 인출 제한
트랜잭션 금액 제한을 설정할 수 있습니다. 이는 사용자가 잘못 판단하여 높은 금액의 인출 가능성을 줄이고, 공격자가 한 트랜잭션에서 지갑의 모든 금액을 가져가는 것을 방지할 수 있다.

- 화이트리스트 및 블랙리스트
사용자는 자신이 지정한 주소(화이트리스트)로만 전송할 수 있고, 차단한 주소(블랙리스트)에는 전송을 안합니다.

- 사기 경보 및 긴급 잠금
장치를 분실하거나 도난당한 경우 계정을 잠그거나 손상된 장치에서 계정에 대한 액세스를 비활성화 할 수 있습니다.


#### 메타 마스크

이더리움을 보유하고 송금 및 관리할 수 있는 암호화폐 지갑입니다. 
구글 크롬 웹브라우저에서 플러그인 방식으로 사용하는 크롬 확장 프로그램으로 사용
지갑 생성은 니모닉 코드(Mnemonic code)를 사용


[이더리움 테스트넷 차이점](https://ethereum.stackexchange.com/questions/27048/comparison-of-the-different-testnets/30072#30072) 참고


#### 마이이더월렛(MEW)
마이이더월렛은 이더리움을 보관하고 입&출금 할 수 있는 암호화폐 지갑

사용자들은 마이이더월렛을 이용하여 블록체인과 바로 통신할 수 있고, 이더리움 지갑을 만들어 이더리움 및 ERC20 토큰들을 보관, 전송 하거나 받을 수 있다.

#### 마이이더월렛 특징

- 하드웨어 지갑 스타일 보안 기능

- 거래를 보호하기 위한 이중 인증

- 개인 키를 얻을 수 없습니다.
    사용자의 개인키를 점유하지 않습니다.

- 탈중앙화
    P2P 통신을 사용합니다.
    개인 데이터를 수집하지 않습니다.
    오픈 소스입니다.

#### Geth Wallet

MacOS Geth 설치
```
brew tap ethereum/ethereum

brew install ehereum
```

Ubybty Geth 설치
```
sudo add-apt-repository -y ppa:ethereum/ethereum

sudo apt-get update
sudo apt-get install ethereum
```

#### Geth 계정 만들기
Geth 명령어를 사용하여 새로운 계정 생성
\* 생성하면 address와 secret key file 경로를 알려줌
secret key file의 경우 절대로 잃어버리시면 안됨.
```
geth account new
```

현재 자신이 가지고 있는 계정 리스트
```
geth account list
```


#### Geth에서 롭스텐 테스트넷 이더 받고, 확인하기

1. Geth JavaScript 콘솔을 사용하여 롭스텐 테스트넷에 접속
```
geth console 2> /dev/null --ropsten
```

\* geth console --ropsten 과 geth console 2> /dev/null --ropsten의 차이점

1. /dev/null

2. 1>/dev/null

3. 2>/dev/null

리눅스로 쉘 스크립트로
/dev/null 1>/dev/null은 같은 의미로, STDOUT(standard output)
정상적인 메세지를 null로, redirect

2>/dev/null는 같은 의미로, STRERR(standard error)
에러 메세지를 null로, redirect

즉, 에러메시지를 출력하지 않게하고싶을떄 사용.

1.위 커멘드 입력 후, 네트워크 연결이 잘 되었는지 확인하기 위해 다음의 명령어를 실행함.
```
> net.listening

```

2. 롭스텐 테스트넷 용 계정을 생성
```
> personal.newAccount();
```
생성 전과 생성 후 아래 커멘더 차이
```
eth.accounts;

# 계정 생성 전
# []
# ["계정"]
```