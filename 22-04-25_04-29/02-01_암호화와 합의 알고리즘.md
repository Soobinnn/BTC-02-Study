# 암호화의 합의 알고리즘

## **Achievement Goals**

- 암호화 기술
    - 해시함수, 디지털 서명
    - 공개키 암호화 , 대칭키 암호화
- 지갑의 종류 구분
- 블록체인의 보안적 특징
    - 이중 지불 문제
    - 51% 공격 등 다양한 공격
    - 안전 문제로 발생할 수 있는 보안적 이슈

암호화 기술은 보안성이 높고, 위변조가 어렵다는 특징이 있어, 데이터 무결성을 쉽게 증명할 수 있다는 장점
-> 암호화 기술은 새로운 신뢰 사회를 구현하기 위한 기반 기술로 주목

* 블록체인에 적용되는 암호화 기술
->  해시 함수, 전자 서명, 공개키 암호화 알고리즘 등 - 보안성 높임

51% 공격, 이중 지불 문제(Double Spending) 등 블록체인의 취약점을 노리는 다양한 공격 방식이 있으며, 
이러한 공격은 블록체인 플랫폼의 펀더멘탈(Fundamental)을 위협 존재함.

## 기존 시스템과 블록체인의 보안적 특징

### 기존 데이터베이스와 블록체인의 보안적 문제와 차이점

1. 무결성

기존 데이터베이스는 클라이언트-서버 아키텍쳐를 사용.
클라이언트는 중앙 서버에 저장된 데이터를 수정할 수 있습니다.

데이터베이스 관리자는 사용자가 데이터베이스에 대한 권한을 가지고 있는지 확인한 후에 접근을 허용.
즉, 관리자에게 데이터베이스에 대한 통제권이 있는 것.
-> 데이터베이스 관리 권한이 뚫리게 되면, 데이터베이스가 해커들의 공격에 의해 변경되거나 삭제될 수도 있다.
* 관리자에게 문제가 생기는 경우 데이터베이스에 큰 보안적 위험이 생김

블록체인은 분산 시스템이기 때문에 각 노드들이 블록체인 사본을 가지고 있으며, 일부 노드에 문제가 발생해도 전체 블록체인 네트워크의 무결성은 보장

2. 변경 불가능성(비가역성)

존 데이터베이스에서 클라이언트는 자신의 권한에 따라 CRUD라고 불리는 데이터 생성, 읽기, 업데이트, 삭제 작업을 수행할 수 있다.

그러나 **블록체인은 오직 데이터를 읽거나 추가할 수만 있습니다. 이전의 모든 데이터는 영구적으로 저장되며, 변경할 수 없다.**

결론, 기존 데이터베이스는 중앙 통제 방식이기 때문에 관리자라는 단일 공격 지점이 존재.
따라서 사용자는 데이터베이스 관리자의 보안 인프라에 의존해야 하며, 데이터베이스 관리를 위한 보안 유지 비용이 소모됨.

반면 블록체인 기술은 분산 데이터 저장 방식을 사용하기 때문에 단일 공격 지점이 없고, 위와 같은 문제를 사전에 차단

\* 이러한 기존 시스템과 차이로, 블록체인에 대한 공격 방식도 기존의 데이터베이스 공격 방식과는 다름

## 블록체인의 보안적 특징

1. 데이터 무결성

    무결성은 데이터베이스가 데이터의 정확성과 일관성을 유지하는 것을 의미.

    **블록체인에서는 합의 알고리즘을 사용해 데이터의 무결성을 보장.**

    합의 알고리즘을 통해 블록에 입력된 데이터에 대해 분산된 각 노드들이 모두 동일한 결과를 가질 수 있도록 함.

    만약 네트워크에 악의적인 노드가 참여하더라도, 합의를 통해 노드가 블록을 변조하지 못하도록 하여 전체 네트워크의 신뢰도를 감소시키지 않도록 함.

    다시 말해, 합의 알고리즘은 네트워크 상에 존재하는 신뢰할 수 없는 노드들이 절차에 맞게 상호 검증하여 네트워크 전체의 무결성을 보장하는 알고리즘.

2. 거래 투명성

    퍼블릭 블록체인의 경우, 누구나 블록체인 네트워크에 접속해 트랜잭션 기록을 확인할 수 있습니다. 
    
    프라이빗 블록체인도 허가된 사용자라면 누구나 트랜잭션 기록을 볼 수 있다.

    거래 기록을 공개적으로 접근할 수 있기 때문에, 네트워크 내의 모든 트랜잭션은 양성화 되어 있으며, 송금 과정의 투명성을 높이기 위한 규제 비용을 절감

3. 감시 가능성

    블록체인은 추가만 가능한(append-only) 데이터베이스로, 한번 블록이 체인에 올라가면, 블록에 담겨있는 트랜잭션이나 데이터는 수정할 수 없다.

    이 과정에서 핵심적인 기술이 바로 해싱(Hashing)이다.

    **새로 생성되는 블록은 이전 헤더의 해시 값이 포함되어 하나의 해시값으로 연결된 블록의 무결성 검증에 사용됨.**
    
    그리고, **블록에 담긴 트랜잭션을 나타내는 머클 트리의 루트 해시값이 블록 헤더에 함께 포함되어 있으며,** 만약 트랜잭션에 변경이 일어나면, 

    머클 해시 값이 변경되므로, 블록체인에 대한 위변조 시도를 바로 발견할 수 있다.

## 해시함수

해싱(Hashing)은 다양한 크기의 입력값을 고정된 크기의 출력값으로 생성해내는 과정.

따라서 해시 함수는 어떠한 크기의 입력값이 들어와도 동일한 크기의 값을 출력하는 함수

오늘날에는 여러 종류의 해시 함수가 존재하며, 그 중 암호 해시 함수는 블록체인 및 다양한 분산 시스템에 데이터 무결성과 보안을 보장하는 데 사용

### 해시 함수의 동작방식

해시 함수는 다양한 크기의 입력값을 사용해 고정된 크기의 출력값을 생성.

ex) SHA-256 알고리즘 -> 어떤 입력값을 넣어도 256 비트 길이의 값을 출력
    SHA-1 알고리즘 -> 160 비트 길이의 값을 출력

### 블록체인에서 해싱의 역할

기존의 해싱 - 데이터베이스 조회, 파일 분석, 데이터 관리 등에 사용

반면, 암호 해시 함수 - 메시지 인증, 디지털 서명 등 보안 어플리케이션에서 사용

특히, **암호화폐 프로토콜에서 가장 중요한 기술 중 하나, 사용자에게 익명성을 보장, 트랜잭션을 하나로 연결 및 압축, 블록을 연결하는 동시에 그 무결성을 보장하는 역할**

1. 해시값을 사용해 익명성 보장

    공개키를 해싱한 값을 지갑 주소로 사용하여 거래를 익명화할 수 있습니다. 
    
    트랜잭션 기록에는 해시값으로 암호화된 지갑 주소와 송금 및 잔액을 확인할 수 있을 뿐, 해당 지갑의 주인이 누구인지 파악할 수는 없음.

2. 무결성 검증

    블록체인에서 해시 함수를 사용해 무결성을 검증하는 경우는 2가지

    1) 이전 블록의 값을 해싱한 값을 사용해 이전 블록을 가리킴.
        
        만약 이전 블록을 해싱한 값이 달라진 경우 해당 블록 또는 가리키고 있던 이전 블록에 위변조가 일어났음을 알 수 있다.

    2) 블록에 저장된 모든 트랜잭션을 머클 트리 알고리즘을 사용해 하나의 해시값으로 저장

        만약 트랜잭션이 하나라도 변한 경우, 블록에 저장된 해시값도 변경

    * 모든 데이터를 대조할 필요 없이, 고정된 크기의 해시값을 비교하면 되기 때문에 많은 양의 데이터를 저장하거나 기억할 필요 없이 무결성을 검증

3. 해시값을 사용해 채굴 노드를 정함

    최초의 블록체인 암호화폐인 비트코인에서는 PoW(작업 증명) 방식을 사용해 어떤 노드가 블록을 만들지 정함.

    작업 증명 방식에서는 특정 조건을 만족하는 해시값을 만족하는 입력값인 논스(nonce)를 가장 먼저 찾는 노드에게 블록을 채굴할 권한을 주고, 채굴에 대한 보상으로 비트코인을 제공

## 암호 해시 함수

일반적으로 암호 해시 함수를 복호화하기 위해서는 수많은 무차별 대입을 시도해야 함.

해시 함수의 출력값은 입력값이 조금만 달라져도 아예 다른 형태로 변하기 때문에, 출력값을 통해 입력값을 유추하는 것은 매우 어렵기 때문

한편으로, 서로 다른 입력값을 해시 함수에 넣었는데 동일한 값을 출력하는 경우도 있습니다. 이를 "충돌"이라 함.

충돌은 시스템에 심각한 위협이 될 수 있기 때문에 충돌은 해시 함수를 만들 때 가장 중요한 요소 중 하나로 작용

\* 해시 함수의 안전성을 평가하는 요소 3가지

- 충돌 저항성

- 역상 저핟성

- 제2 역상 저항성

### 충돌 저항성

서로 다른 입력값이 동일한 출력값을 갖게 되는 것을 충돌이라 함.

충돌 저항성은 어떤 해시 함수가 충돌하는 서로 다른 두 입력값을 가지고 있는지 발견되지 않은 상태를 의미.

- example

이는 마치 사람의 지문과 같습니다. 지문은 완전히 같을 확률이 매우 적기 때문에, 사람을 식별할 때 주민번호를 일일이 입력하는 대신 지문을 사용.

사실상 해시 함수의 입력값은 그 길이와 종류가 무한하지만, 입력값은 유한하기 때문에 누군가가 충돌하는 두 입력값을 발견할 가능성

그러나 해시 함수의 충돌을 발견할 가능성은 매우 적습니다.

가령 SHA-256는 비트로 환산하면 256가 비트가 되며, 경우의 수는 2^256 -> 2^256은 10^78 -> 우주의 모든 원자의 갯수가 10^80개라는 것을 감안하면 사실상 SHA-256의 충돌을 찾는 것은 불가능

따라서 충돌이 없는 해시 함수는 존재하지 않지만, 충돌 저항성이 있다고 간주되는 해시 함수는 존재

\* 양자 컴퓨터를 사용하게 된다면, 계산 성능을 획기적으로 늘리는 것이 가능하기 때문에 2^256 개의 가능성을 일일이 대입하는 것이 어렵지 않을 것입니다. 

그러나 양자 컴퓨터가 어느 순간 갑자기 보편화될 가능성은 적기 때문에 지금 당장 걱정할 필요는 없음.

### 역상 저항성

역상 저항성은 어떤 해시 함수가 특정한 값을 출력하는 입력값을 찾을 확률이 매우 낮을 경우를 의미.

이는 단방향 함수의 성질과 연관됩니다. 단방향 함수는 입력값을 통해 출력값을 얻을 수는 있지만, 출력값을 통해 입력값을 얻을 수는 없는 함수임.

역상 저항성은 데이터를 보호하는 데 매우 유리.
-> 메시지의 해시값을 사용하면 해당 메시지의 원본을 공개하지 않고도 진위성을 검증

\* 실제로 패스워드에 대한 진위성을 검증할 때도 패스워드 원문을 비교하지 않고, 패스워드를 해싱한 값을 사용하여 패스워드가 노출되는 것을 방지


### 제2 역상 저항성

충돌 저항성과 역상 저항성이 복합적으로 작용한 경우, A라는 입력값의 해시값과 동일한 해시값을 내는 B 입력값을 누군가가 알고 있지 않은 경우.

반대로 이 B 입력값을 누군가가 발견한 경우 제2 역상 공격이 가능

충돌 가능성은 동일한 해시값을 가진 서로 다른 두 입력값을 찾는 것이지만,

제2 역상 공격은 A 입력값을 통해 A' 라는 해시값이 나왔을 때, A' 해시값을 출력하게 만드는 B 입력값을 찾는 것

따라서 제2 역상 저항성은 충돌 저항성이 전제되야함.