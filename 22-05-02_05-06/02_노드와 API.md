# 노드
블록체인이 유지되기 위해서는 사용자들의 노드(Node)를 운영 해야함.

## 노드(Node) 란?

보통 컴퓨터 전공을 하는 사람들에게 노드라는 개념은 하나의 단위 
- 연결리스트는 '노드'라는 객ㅊ페로 이루어짐.

> 연결리스트 : linked list라고도 하며 순서를 가지는 자료들의 저장과 탐색을 위해 각 데이터에 이전 데이터나 이후 데이터의 참조를 추가적으로 기록하여 자료들을 연결하는 자료구조

노드의 기본적인 자료구조

DATA, Next Address

각 노드는 연속된 공간에 저장되어 있지 않고 메모리의 여러 부분에 분포

각 노드에 다음 노드의 주소를 저장함으로써 다음 노트를 탐색할 수 있습니다. 다음 주소를 가리켜야 하기 때문에 포인터를 이용해 구현할 수 있다.

노드가 가리키는 다음 주소가 NULL이면 이 노드는 마지막 노드

## 연결리스트 (linked list) 구현

연결리스트를 구현하기 위해서는 다음과 같은 함수를 구현해야함.

```
초기화(init) / 삽입(Insert) / 삭제(Remove)
```

### 초기화

노드를 접근하기 위해서는 맨 처음 노드의 주소를 가리킬 노드가 필요 -> 이를 head라고 
맨 마지막 노드를 가르키는 노드는 tail 이라고 표현

초기화하는 과정에서 다음 주소를 가리키는 포인터는 null로 설정합니다. null은 '가리키는 노드가 없음' 을 의미

### 삽입

삽입을 구현하는 방법은 세가지 방법

1) 맨 앞에 삽입하는 방법
    : 새로 추가되는 노드의 다음주소  --> 현재 head가 가리키는 주소
      head가 가리키는 주소 --> 새로 추가된 노드  

2) 맨 마지막에 삽입하는 방법
    : 맨 앞에 삽입하는 경우와 거의 같다. -  head 대신 tail를 사용
    여기서 tail 노드의 필요성을 알 수 있다. 만약 tail노드가 없다면 매번 삽입할 때마다 처음부터 끝까지 탐색해야 하는 번거로움이 발생
    그래서 매번 O(n)의 시간복잡도가 발생한다. 만약 tail노드가 있다면 O(1)의 시간복잡도로 처리

    새로 추가되는 노드의 다음주소  -->  Null (마지막 노드이기 떄문에)
    tail이 가리키는 노드의 다음 주소 - > 새로 추가되는 노드
    tail이 가리키는 주소 --> 새로 추가된 노드

3) 원하는 위치에 삽입하는 방법
    먄약 2번쨰, 3번쨰자리에 추가하고 싶다! or 정렬을 하면서 추가하고 싶은 경우,
    이럴 경우엔 탐색을 통해 원하는 위치를 찾고 그 위치에 새로운 노드를 추가해야함.

    우선 삽입할 위치를 찾는 노드 cur (current)가 필요.
    example) 2번째노드(4)와 3번째노드(1) 사이에 추가한다고 가정
    1. 탐색을 통해 cur노드가 4를 가리키게 만듭니다.
    2. 새로운 노드 5가 가리키는 주소 --> cur이 가리키는 노드4가 가리키는 다음 노드(1)
    3. cur이 가리키는 노드4가 가리키는 다음노드 --> 새로운 노드 5

### 삭제

'원하는 자리에 삽입' 하는 과정과 유사

그러나 삭제할 노드의 전과 삭제할 노드의 후를 연결해줘야 하기 때문에 또 하나의 노드가 필요

이 노드를 pre라고 표현. 

삭제할 노드를 1 이라고 가정

1. 탐색을 통해 삭제할 노드를 cur이 가리키게 하고 , 삭제할 노드의 바로 전 노드를 pre가 가리키게 함.

2. pre가 가리키는 노드의 다음 주소 --> cur이 가리키는 다음 주소

3. cur이 가리키는 노드는 노드의 메모리 주소를 비워 줍니다.


## 블록체인에서의 노드란?

블록체인의 노드는 트리 구조로 되어있음.

전 세계적으로 수십만개 이상이 존재하는 서버들을 노드(Node)라고 합니다.
노드(Node)는 기능과 필요에 따라 종류와 형태가 구별되고, 자신이 맡은 역할에 따라 다양한 기능을 수행

즉, 노드(Node)를 서버(Server)라고 했을 때, 서버의 역할이 데이터 저장만 하는 게 아닌 것처럼 노드 역시 다양한 기능을 수행

노드는 트랜잭션을 제안하고 검증할 수 있으며, 합의를 이루고, 블록체인을 보호하기 위해 채굴(Mining)을 수행하기도 함.

또 다른 면으로는 계정의 역할도 하기 때문에 프라이빗 블록체인(Private blockchain) 또는 하이퍼레저 패브릭의 멤버쉽 서비스 같은 폐쇄형 블록체인 네트워크에서는 
계정 역할의 노드(Node)가 꼭 필요

> 하이퍼레저 패브릭의 멤버쉽 서비스
하이퍼레저 패브릭의 멤버십 서비스는 CA(인증 기관), MSP(권한 부여), Identity Mixer(서명 증명) 등을 이용해 패브릭 네트워크 사용자의 접근을 제어하는 기능을 제공

## 노드의 종류

- 지갑 (wallet)
    : 지갑은 사용자의 개인키와 공개키를 관리하고 거래에 사용되는 주소를 생성하는 기능을 담당

- 풀 노드 (Full node)
    : 풀노드(Full node)는 블록체인에서 이뤄진 모든 거래 정보를 전부 저장하는 노드
    제네시스 블록부터 시작해서 현재 블록까지 모든 블록체인 정보를 수집, 저장

    풀노드는 자신의 PC에 모든 블록체인의 내용을 가지고 있기 때문에 다른 노드의 도움없이 스스로 거래 검증이 가능.
    하지만 용량이 너무 커서 다운로드를 받는데 시간이 오래 걸리고 하드디스크의 용량을 많이 차지한다는 단점    

    제네시스블록(Genesis block)은 블록체인에서 생성된 첫 번째 즉, 최초의 블록입니다. 
    첫 번째 블록이 생성된 이후에 다음 블록이 지속적으로 생성되어 마치 체인처럼 이전 블록에 연결되기 때문에, 
    제네시스블록이 생성되었다는 것은 해당 블록체인 네트워크가 시작되었다는 상징적 의미
    (타임스탬프와 블록이 컨펌되는 시간이 다를 수 있기 때문에 정확히는 "제네시스 블록이 첫번째 블록이 아닐 수 있다."는 설도 있음)
    

- 라이트 노드 (Light node)
    : 풀노드의 단점을 해결하기 위해 나온 것이 라이트 노드(Light node)
    라이트 노드는 블록체인에 참여하여 거래를 수행하는 노드로, 풀노드에 거래 데이터를 요청하여 개별 거래를 검증하는 기능을 수행
    풀노드처럼 모든 블록 정보의 원본을 가지고 있지는 않고 일종의 요약본, 즉 블록헤더에 있는 중요한 데이터만 보유하고 있게됨

    즉, 라이트 노드는 가볍고 풀노드와 다르게 자료의 일부분만을 다운받는 대신 거래를 위해 내용 검증이 필요할때마다 풀 노드에게 자료를 요청해야만함.

- SPV (Simple Payment Verification)
    : 라이트웨이트(Lightweight)노드와 동일한 개념
    말 그대로 ‘단순 지불 검증 노드’로서 풀 블록체인을 저장하지 않아도 특정 거래를 확인할 수 있는 노드
    흔히 오해하는 중요한 사실은 **SPV노드는 거래를 ‘확인’할 수 있지만 ‘직접 검증’할 수는 없다.**

    해당 노드는 거래가 담긴 블록의 깊이와 높이를 참고하여 단순 검증(안전하게 보관 되었다는 검증)은 할 수 있지만, 
    거래 전부에 대한 기록이 없기에 직접 검증(거래 자체가 적합한지)은 불가능하다.

    UTXO의 소비 여부 또한 검증할 수 없다.

    SPV노드는 이웃 노드들에게 지불 검증을 위해 필요한 데이터를 요청하게 됩니다. 
    하지만 이러한 과정에서 SPV노드는 자연스레 프라이버시를 노출하게 됩니다. 즉, 필요하고자 하는 데이터가 무엇인지 그대로 전달해야 함.
    이러한 점을 보완하기 위해 ‘블룸필터(Bloom Filter)’를 사용하여 원하는 데이터를 얻으면서 프라이버시를 유지

- 마스터 노드 (Master node)
    : 마스터노드(Master node)는 풀 노드(Full node) 중에서 권한과 보상을 받는 노드로 주인. 혹은 상위 노드로 표현
    풀 노드는 블록체인 데이터를 전부 저장해 네트워크에 기여하는 의무를 갖고 있고, 마스터 노드는 풀 노드의 의무를 수행하면서 블록생성에 대한 보상(투표 실시)을 받고, 
    트랜잭션의 추가기능 (익명, 즉시 전송)을 수행

- 채굴 노드 (Mining node)
    : 새로운 블록을 가능한 빠르게 채굴하는 것
    채굴 노드는 작업증명(PoW) 방식을 채택한 블록체인에만 존재하는데, 채굴은 실질적으로 작업증명 방식에서 퍼즐을 푸는 일이기 때문

- 랜덤 노드 (Random node)
    : 전체 블록체인의 무결성을 유지하기 위해 임의로 선택된 노드로서, 선출된 마스터노드와 함께 블록을 생성

- 엔드포인트 노드(Endpoint node)
    : 카카오의 자회사인 그라운드X가 개발한 플랫폼인 클레이튼에 적용된 노드
     처음에는 레인저노드(Ranger node)라고 부르다가, 이후에 조정된 역할을 정확하게 기술하기 위해 이름을 엔드포인트 노드로 변경

- 합의 노드(CN: Consensus nodes)
    : 트랜잭션을 새로운 블록으로 배치하고, 비잔틴 장애 허용(BFT; Byzantine Fault Tolerance) 합의 알고리즘을 사용하여 블록들을 확인하는 작업을 담당
    합의 네트워크를 형성하는 노드.

    블록체인에서 블록을 생성하는 노드로 블록체인을 유지하기 위해서는 합의노드가 존재하여야 하며 스마트 계약 실행이나 거래 확인은 합의 노드에서 수행

- 슈퍼 노드 (Super node) or 대표 노드 (Representative node)
    : 블록체인 네트워크의 노드들을 대표해 블록을 생성하고 그에 대한 보상을 받는 노드로 위임지분증명(DPoS) 합의 알고리즘을 채택하고 있는 블록체인에서 특징적으로 볼 수 있는 시스템

- 베이킹 노드 (Baking node)
    : 테조스(Tezos) 블록체인에서 사용하는 용어로, 코인 소유자로부터 위임받은 코인으로 베이킹(baking)을 하는 노드
     베이킹(Baking)은 테조스 블록체인에서 블록을 생성하고 블록을 입증하는 방법으로, 채굴과 동일한 의미

- 히스토리 노드 (History node)
    :  블록에 있는 데이터를 찾을 수 있는 노드
    이더리움 API 서비스 제공 업체인 인퓨라(Infura)는 이 히스토리 노드의 데이터를 이용한 새로운 BM(Business Model)을 운영

### 블룸필터(Bloom Filter)

특정 패턴을 설정하여 조건을 맞추는 데이터를 취합하게 해줌.

example)
SPV 노드는 ‘skkrypto가 보낸 거래’를 찾기 위해 ‘pto 끝나는 사람이 보내는 거래’를 요청하는것과 같습니다.
정확성을 높이기 위해서는 ‘조건’을 구체화시켜야 하지만 그만큼 프라이버시는 노출됨.

여러가지 패턴을 더해 이루어지는 블룸필터는 BIP37에 규정되어 있으며 실제 구동방식은 훨씬 더 구체적이고 복잡함.
참고 https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki

### 노드 - Network Routing

블록체인상의 P2P 네트워크 전송기능을 담당함.

4가지 기능 조합으로 다양한 형태로 노드가 형성 됨.

1. Reference Client
    : 모든 노드를 포함한 완전한 네트워크의 형태입니다. Bitcoin Core가 여기에 해당
    (Wallet, Miner, FullBlockchain, Netwrok Routing)

2. Full Blockchain Node
    : 네트워크 라우팅 기능과 모든 블록체인 데이타를 가진 형태
    (FullBlockchain, Network Routing)

3. Solo Miner
    : 지갑기능은 제외하고 채굴에 특화된 형태의 노드
    (Miner, FullBlockchain, Netwrok Routing)

4. Lightweight wallet(SPV : Simplified Payment Verification)
    : 지갑기능과 네트워크 라우팅기능만 포함된 노드로 전체 블록체인 데이타는 없이 단순히 거래와 유효성 검증만 가능한 스마트폰에 설치된 지갑등과 같은 노드
    (Wallet, Netwrok Routing)

\* 위에 언급한것처럼 Full blockchain 데이타는 170기가가 넘는 용량을 차지하기 때문에 스마트폰에는 Full Blockchain Node의 형태로 설치하기가 불가능

\* 모든 노드는 Network Routing 기능을 포함.

## 블록체인의 분기

채굴노드에서 채굴에 성공된 블록이 인근노드로 전파가 시작되면 해당 블록을 전달받은 노드들은 그 블록의 유효성을 검사하여 유효한 경우 
자신의 메인체인에 블록을 연결하여 블록체인의 길이를 연장시키고 다시 인근노드로 블록을 전달

이과정이 순차적으로 이루어져 전체 블록체인에 동일한 블록이 추가되게 됨.

하지만, **동시에 두개의 유효한 블록이 생성되어 전파되는 경우 일시적으로 블록체인이 두개의 브렌치로 분기가 발생할수 있다.**

이와같이 순간적으로 블록체인의 분기가 발생하게 되더라도 바로 다음블록의 생성시점에 하나의 메인체인으로 수렴이 이루어지게 됨.

## API

이더리움(Ethereum)은 Web3를 촉진하기위해 Web3.js 라는 자바스크립트 API를 제공

이 API를 통해, 대표적으로 분산 네트워크 환경을 제공하는 퍼블릭 블록체인, 이더리움 네트워크와 연결하여 (dApp)을 개발하고, Web3 커뮤니티에 참여할 수 있다.

> Javascript 뿐만 아니라, 하스켈, 자바, PHP, 파이썬 등의 다른 언어를 위한 API 제공 라이브러리도 있다.

