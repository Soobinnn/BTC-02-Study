# 스마트 컨트랙트와 Web3

스마트 컨트랙트는 기존 금융 시스템 위에서 동작하는 비즈니스를 파괴하고, 블록체인에서 작동하는 새로운 형태의 프로그래밍 계약서이다.

스마트 컨트랙트는 상호 약속된 계약 규칙대로 작동하기 때문에 기존의 중앙화된 계약의 틀을 깨고, 새로운 형태의 비즈니스를 프로그래밍화하여 구현할 수 있다.

따라서 **스마트 컨트랙트는 해킹 위험이 낮고, 보안 비용과 수수료가 절감되며, 계약의 투명성을 보장한다는 특징**

스마트 컨트랙트를 활용하여 블록체인은 대출, 보험, 증권, 저작권, 공유경제, 물류유통 등 다양한 방면의 기존 금융 서비스를 대체하고, 
나아가 DeFi, NFT 등 새로운 형태의 비즈니스를 생산한다.

## 스마트 컨트랙트

**블록체인 네트워크에 호스팅되고 실행되는 프로그램**

스마트 컨트랙트는 **조건을 지정해두고, 해당 조건이 충족되면 미리 정해둔 계약을 이행하는 방식으로 코드를 작성**

스마트 컨트랙트는 **일반적인 중앙 집중식 서버가 아니라 탈중앙화된 블록체인에서 실행하기 때문에, 계약 조건이나 이행 내용을 변조하기 어려우며 계약을 신뢰하기 위한 제3자가 필요하지 않다.**


### 스마트 컨트랙트의 역사

스마트 컨트랙트의 개념은 1994년 닉 재보(Nick Szabo)에 의해 만들어짐
Nick Szabo는 다음과 같이 정의함.
```
"계약 조건을 실행하는 전산화된 트랜잭션 프로토콜"은 "일반적인 계약 조건을 만족하고, 악의적이거나 우발적인 예외를 최소화하며, 신뢰할만한 중개자의 필요성을 최소화하는 것"을 목표로 한다.
```

Nick Szabo는 스마트 컨트랙트가 마치 자판기와 같다고 말했다.
이 과정에서 자판기와 나 사이에는 "커피 제공"이라는 계약이 있습니다. 그리고 이 계약 사이에는 제3자가 없다.

스마트 컨트랙트를 위한 비트 골드(bit gold)를 제안했으나, 기술적 한계로 인해 실제로 구현되지는 못함.
-> 스마트 컨트랙트를 실제로 지원하기 시작한 첫 화폐는 2009년 출시된 비트코인이다.

**스마트 컨트랙트를 지원할 수 있는 핵심적인 이유는 비트코인의 핵심 기술인 블록체인이 디지털이며, 위조를 방지할 수 있고, 제3자가 필요하지 않기 때문**

다만, 비트코인의 경우 오피코드(opcode)를 사용해 화폐 거래를 위한 제한적인 스크립트만을 작성할 수 있었기 때문에 프로그램 구현 시 제약이 많았다.

> opcode : 비트코인에서 스마트 컨트랙트를 동작시키는 연산들의 집합

2015년에는 프로그래밍 가능한 스마트 컨트랙트를 위한 블록체인인 이더리움이 등장함.

이더리움에서는 솔리디티(Solidity)라는 언어를 통해 스마트 컨트랙트를 위한 코드를 작성하고,
EVM(Ethereum Virtual Machine)을 통해 이더리움 블록체인 위에서 코드를 실행시킬 수 있다.

-> 이를 통해 이더리움은 여러개의 독립적인 스마트 컨트랙트를 동시에 실행할 수 있어서 "월드 컴퓨터(World Computer)"라고 불리기도 함.

### 스마트 컨트랙트의 동작방식
스마트 컨트랙트의 로직은 다음과 같다.
```
if or when (이벤트 x가 실행되면) {  // 조건
	액션 y를 실행하라  // 계약 이행
}
```

코드가 블록체인 네트워크에 올라가면, 네트워크는 미리 결정된 조건이 충족되고, 검증된 경우 조건에 따른 액션을 실행함.

이러한 액션은 트랜잭션에 기록되며, 완료된 트랜잭션은 블록체인에 올라감.
다시 말해, **스마트 컨트랙트는 한번 액션이 수행되면 되돌리거나 수정할 수 없다는 것을 의미**

따라서 스마트 컨트랙트는 당사자가 스마트 컨트랙트와 상호작용하는 방법을 정의하고, 누가, 언제, 어떤 입력이 어떤 결과를 초래하는지 담고 있다.
결과 값이 담겨있다는 것은 어떤 "확률적"인 상태(probabilistic state)가 아니라, 조건에 따른 결과가 미리 결정되어 있다는 것을 의미
코드에 따라 계약이 실행됨을 보장하는 "결정론적"인 상태(deterministic state)인 다자간 디지털 계약이 바로 스마트 컨트랙트다.

개발자라면 누구나 스마트 컨트랙트를 만들고 퍼블릭 블록체인에 배포할 수 있다.

### 스마트 컨트랙트의 장점

스마트 컨트랙트는 일반적인 중앙집권화된 디지털 계약과는 다른 몇가지 장점이 있다.

- 보안
    : 스마트 컨트랙트는 분산형 블록체인 인프라 위에서 실행되기 때문에, 한번 스마트 컨트랙트 코드가 블록체인 네트워크에 올라가면 모든 노드가 스마트 컨트랙트 내용과 이행 결과를 가지게 됨. -> 따라서 계약에 대한 중앙화된 공격 지점이 없고, 누군가에게 뇌물을 주고 계약 내용이나 결과를 변조할 위험이 없음.

- 신뢰성
    : 스마트 컨트랙트 로직이 조건에 부합해 계약이 이행되면 블록체인 네트워크에 있는 노드들에 의해 여러번 수행되고 검증되기 때문에, 위변조가 매우 어렵고 정확성이 높음.

- 공평함
    : 계약 조건을 공유하고 강제하기 위해 분산화된 블록체인 네트워크를 사용하기 때문에, 수수료를 가져가는 등 영리적 목적의 중개자가 필요하지 않음.

- 효율성
    : 계약 이행을 자동화하기 때문에 계약 당사자들은 수동으로 데이터를 입력하거나, 상대방의 계약 의무 이행 여부 검증하거나, 중개자가 계약을 집행하는지 확인할 필요가 없음.

## 비트코인에서 스마트 컨트랙트
### 비트코인 스크립트
비트코인에서는 스크립트(Script)라는 스크립터 언어를 사용해 스마트 컨트랙트를 구현함.
-> 일반적으로 비트코인에서 사용하는 스크립트는 비트코인 스크립트라고 부름.

비트코인 스크립트는 일반적인 프로그래밍 언어와는 다르게 어떤 공식적인 문법이나 구문이 있는 것은 아님.
대신 **간단한 연산 목록으로 구성**되어 있음. **스크립트에서 사용하는 연산들은 opcode에 해당하며, 이 연산들은 C++로 작성되어 있다.**

스크립트는 트랜잭션에 연결되어 있다. 네트워크의 모든 노드는 트랜잭션을 받을 때마다 자신의 로컬 컴퓨터에서 트랜잭션에 연결된 스크립트를 실행함.

이 스크립트 실행을 통해 비트코인의 송금이 이루어짐. 이러한 특징으로 인해 비트코인은 프로그래밍 가능한 화폐(programmable money)에 대한 대중성을 부여했다고 볼 수 있다.

트랜잭션은 블록체인에 한번 올라가게 되면 위변조가 매우 어렵기 때문에, 모든 노드는 동일한 스크립트를 실행하고, 정확히 동일한 결과를 얻게 됨.

만약 악의적인 노드가 변조한 트랜잭션을 퍼뜨린다면, 변조된 트랜잭션의 스크립트 실행 결과와 다른 트랜잭션의 스크립트 실행 결과가 달라질 것

### 입력값과 출력값

비트코인 트랜잭션은 입력(Inputs)과 출력(Outputs) 목록을 가지고 있다.

출력은 잠금(lock)과 값을 가지고 있으며, 입력은 연결된 과거의 출력을 가리키는 포인터와 해제 키를 가지고 잇다.
스크립트는 이 잠금과 해제 메커니즘에 관한 것.

입력 구조에 있는 Prev. TxID와 TxIndex는 해제하고자 하는 이전 출력을 가리킴.
scriptSig는 이전의 출력을 해제하는 키

#### 입력 구조
- Prev. Tx ID, TxIndex : 해제하고자 하는 이전의 출력을 가리키는 포인터
- ScriptSig : 이전의 출력을 해제하는 키

#### 출력 구조
- ScriptPubkey : 잠금. ScriptPubkey의 소유자(해당 공개 키의 소유자)만이 ScriptSig를 만들 수 있다.

- Amount : 잠긴 비트코인의 양

노드는 피어로부터 트랜잭션을 받으며, 먼저 해당 트랜잭션 안에 들어있는 입력과 출력 목록에서 각 입력과 출력에 해당하는 ScriptSig와 ScriptPubkeys를 추출함.

그리고 기존 블록들을 찾아보며, 입력과 연결된 이전 출력을 찾고, 각 입력과 출력에 들어있는 ScriptSig와 ScriptPubekey를 연결시킨다.

ScriptSig와 ScriptPubkey는 각각 연속적인 정보를 담고 있습니다. 
노드가 ScriptSig와 ScriptPubkey를 연결하고, 그 연결한 전체 시퀀스를 파싱하면 온전한 스크립트 코드가 나타나게 된다.
노드는 이 코드를 단계 별로 실행합니다.

### 비트코인 스크립트가 스마트 컨트랙트인 이유

UTXO의 ScriptPubkey는 일종의 수학적 퍼즐의 형태이고, 올바른 ScriptSig를 추가함으로써 이 퍼즐을 풀 수 있다.

**UTXO는 일종의 "계약"으로 정의될 수 있으며**, 이 계약은 유효한 해제 조건이 주어지면 잠긴 비트코인을 이동시킨다.
오직 유효한 해제 조건이 주어져야만 코인을 송금할 수 있는 계약인 것이다.
이 계약의 실행은 비트코인 네트워크가 보장하기 때문에 계약 이행을 강제하기 위한 중개자가 필요하지 않다.

## 이더리움에서의 스마트 컨트랙트

### 이더리움 소개

이더리움은 블록체인 기술을 활용해 스마트 컨트랙트와 암호화폐 거래를 제3자 없이 안전하게 이뤄질 수 있도록 하는 오픈소스 퍼블릭 서비스.

누구든지 분산형 어플리케이션(dApp)을 이더리움 네트워크에 배포할 수 있다.

이더리움은 개발자들이 dApp을 만들 수 있도록 튜링 완전한 언어인 솔리디티(Solidity)를 제공하였으며,
이더리움 네트워크에 올라간 솔리디티 코드는 EVM(Ethereum Virtual Machine)을 통해 실행됨.

### EVM

Ethereum virtual machine layer

- code - EVM code

- virtual machine - EVM

- (software) runtime system (process) - Etherum node (Geth, Parity, ...)

- (hardware) Physical Processor (x86, ARM, ..)

EVM(Ethereum Virtual Machine)은 우리가 짠 코드와 이더리움 블록체인 사이에 있는 가상 머신으로, 블록체인에서 코드가 실행될 수 있도록함.

이더리움 스마트 컨트랙트에 기반한 dApp은 솔리디티라는 언어로 작성됨.

그런데, 솔리디티 언어는 고급 언어이기 때문에 EVM이 이해하기 어렵다. 
EVM은 솔리디티를 읽을 수 없기 때문에, 먼저 우리가 작성한 솔리디티 코드를 solc를 이용해 컴파일하여 EVM이 읽을 수 있는 바이트코드 형태로 만듦.
그리고 이 바이트코드를 geth를 이용해 이더리움 네트워크에 올림.

**솔리디티 코드 -> 바이트 코드 -> opcode**

블록체인에 저장된 바이트코드 형태의 dApp은 EVM에서 실행하게 되며, EVM에서는 바이트코드를 opcode로 변환하여 실행함.

\*솔리디티로 작성된 스마트 컨트랙트는 EVM에서 동작하기 때문에 특정 운영체제나 하드웨어에 종속되지 않음.

### 바이트 코드 동작방식

**opcode를 효율적으로 저장하기 위해, opcode는 바이트코드(bytecode)로 인코딩됨.**

모든 opcode에는 1바이트가 할당된다. \*가령 STOP 은 0x00임

0x6001600101이라는 바이트코드가 있다고 가정하자.

코드가 실행되면 바이트코드는 바이트로 쪼개진다. (1 바이트는 2개의 16진수 문자입니다.) 

첫번째 명령어의 첫번째 바이트 0x60는 PUSH1 연산입니다. PUSH1 연산 뒤에는 스택에 추가할 데이터가 옵니다. 따라서 명령어의 두번째 바이트 0x01을 스택에 추가합니다.

두번째 명령어는 첫번째 명령어와 같기 때문에 동일하게 스택에 0x01이 쌓입니다.

세번째 명령어 0x01은 ADD 연산입니다. 이 연산은 스택에서 요소 두 개를 꺼내오고 두 요소의 합을 스택에 추가합니다. 

스택에서 0x01, 0x01 두 개를 꺼내오고 더한 결과값 0x02를 스택에 추가합니다.

## 솔리디티(Solidity)
솔리디티는 스마트 컨트랙트를 실행하는 객체 지향(object-oriented), 정적 타입(static typed), 고급(high-level) 스크립트 언어로  EVM에서 실행됨.

솔리디티는 컨트랙트 기반의 고급 프로그래밍 언어

자바스크립트와 같은 스크립트 언어의 구문과 매우 유사.
솔리디티는 C++과 파이썬, 자바스크립트를 기반으로 만들어졌으며, 이더리움 네트워크에서 스마트 컨트랙트를 생성할 수 있도록 설계됨.

솔리디티는 정적 타입 스크립트 언어로, 런타임 언어와는 달리, 컴파일 시 제약 조건을 확인하고 적용.

### 역사
솔리디티는 2014년 8월 컴퓨터 과학자 가빈 우드(Gavin Wood)가 처음 제안
우드는 이더리움에서 2년간 CTO로 재직했으며, 크리스찬 라이트와즈너(Christian Reitwiessner)가 우드를 이어받아 솔리디티 개발을 이끔. 그 결과 2015년 8월 솔리디티가 정식 출시

### 솔리디티로 할 수 있는 일
솔리디티는 이더리움 네트워크의 기반입니다. 

이더리움을 위해 특별히 제작된 솔리디티(Solidity)는 EVM상에서 작동하는 스마트계약을 개발하기 위해 설계됨.

### 솔리디티는 튜링 완전 언어이다

비트코인 스크립트와 비교해서 **솔리디티의 가장 큰 특징은 튜링 완전/불완전 이다**

#### 튜링 머신

튜링 머신은 실제로 구현된 기계가 아니라, 이론상으로 존재하는 기계로, 오늘날 우리가 구축할 수 있는 가장 강력한 기계 컴퓨터를 설명할 때 사용하는 수학적 연산 모델임.

어떤 프로그래밍 언어나 추상 기계가 튜링 머신과 동일한 연산 능력을 가질 때, 우리는 그것이 튜링 완전(Turing-Complete)하다고 말함.
반대로 튜링 머신보다 연산 능력이 떨어질 경우 튜링 불완전(Turing-Incomplete)하다고 함.

\*  지금은 튜링 머신이 우리가 일반적으로 아는 컴퓨터 언어들처럼 기본적인 연산과 조건문, 반복문 등을 모두 수행할 수 있는 기계 정도로 이해하면 됨.

#### 스마트 컨트랙트와 튜링 완전, 불완전성

비트코인 스마트 컨트랙트에서는 opcode를 사용해 스크립트를 구성하였다. 그러나 비트코인 스크립트에는 치명적인 단점이 하나 있음.

바로 몇가지 opcode를 사용할 수 없다는 점. -> 사토시 나카모토는 무한 반복 공격과 같은 보안상의 이슈를 고려해 의도적으로 반복문 opcode를 제외했다.

따라서 **비트코인 스크립트를 두고 튜링 불완전하다고 말함**

비트코인으로 스마트 컨트랙트를 구현할 때는 반복문을 사용할 수 없다 보니, 단순한 스마트 컨트랙트를 만드는 데에 그칠 수밖에 없다.

**이더리움의 핵심은 이러한 비트코인의 튜링불완전성이라는 한계를 넘어, 개발자가 원하는 스마트 컨트랙트를 유연하게 구현할 수 있도록 튜링 완전을 제공하는 것.**

**EVM은 반복문 opcode들을 지원하는 대표적인튜링 완전 머신이며**, **솔리디티는 튜링 완전 머신을 동작하게 하는 튜링 완전 언어이다.**

### 솔리디티 개발 도구
dApp의 백엔드 개발 도구들은 대표적으로 다음과 같은 것들이 있다.

- Remix IDE
    : Remix는 솔리디티를 사용한 dApp 개발을 도와주는 통합 개발 환경.
    Remix IDE는 자바스크립트로 만들어졌기 때문에 브라우저에서 사용가능하며, 로컬이나 데스크톱 버전을 사용할 수도 있다.

- solc
    : 솔리디티는 고급 언어이기 때문에 가상 머신인 EVM은 솔리디티를 읽을 수 없다. 따라서 솔리디티를 바이트코드로 컴파일해야 하는데, 이때 사용하는 컴파일러가 solc

- Ganache
    : Ganache는 개발 단계에서 시뮬레이션 테스트 환경을 구성해주는 도구.
      Ganache를 사용하면 채굴 없이 가상 이더리움 환경에서 트랜잭션 제한 없이 테스트를 할 수 있다

- TestNet
    : 이더리움에서 제공하는 퍼블릭 테스트 네트워크를 TestNet이라고 함. 
    테스트 네트워크는 실제 이더리움과 비슷하지만 실제 트랜잭션이 이루어지지는 않습니다. 이더리움에는 현재 Ropsten, Kovan, Rinkeby 세 개의 퍼블릭 테스트넷이 제공되고 있다.

- 프레임워크 : Truffle, Embark, Dapple
    : 솔리디티 코드를 이더리움 네트워크에 올리기 위한 여러 복잡한 과정을 해결해주는 다양한 프레임워크들이 있다.
    이 프레임워크들은 솔리디티 코드에 대해 테스트, 디버깅, 컴파일, 배포를 제공함.

## 스마트 컨트랙트 동작원리

### 이더리움은 상태 머신
이더리움은 거래에 기반을 둔 상태 머신(transaction-based state machine)이다.
-> 상태 머신이란 일련의 입력을 읽고, 그 입력을 기반으로 새로운 상태로 전환하는 것을 의미.

이더리움이라는 상태 머신은 Genesis state에서 시작함. 그리고 트랜잭션이 실행되면, 다음 상태로 전환하게 됨. 
더이상 트랜잭션이 들어오지 않은 마지막 상태가 바로 이더리움의 현재 상태

이더리움의 상태에는 수천 개의 트랜잭션이 있다. 이 트랜잭션은 "블록"이라는 그룹에 묶여 있으며, 블록은 직전에 만들어진 블록과 이어져 있음.

### 전역 상태
**이더리움의 전역 상태**는 **계정 주소와 계정 상태를 매핑한 것으로 구성**되어 있다. 
-> 이 매핑은 머클 패트리샤 트리(Merkle Patricia Tree) 형태로 저장되어 있음.

머클 트리(Merkle trie, Merkle tree)는 이진 트리의 한 종류로, 다음의 특징을 가지고 있다.

- 트리 맨 아래에 있는 노드들은 데이터를 가지고 있다.

- 부모 노드는 두 자식 노드를 모아 해싱한 값을 가진다. 맨 위의 루트 노드도 자식 노드의 해싱한 값이다.

트리 맨 아래에 있는 데이터는 저장하려는 데이터를 청크로 분할한 다음, 
각 청크를 두개씩 모아 해시를 취하여 부모 노드를 만듭니다. 그렇게 하나의 루트 노드가 만들어질때까지 동일한 과정을 반복함.

**이더리움의 블록 헤더**에는 **세 개의 머클 트리 구조의 루트 노드의 해시값이 저장**되어 있다.

1. 상태 트리(state tree) : 트랜잭션과 연관된 계정의 상태 정보 저장

2. 트랜잭션 트리(transaction tree) : 현재 블록의 트랜잭션 정보 저장

3. 영수증 트리(receipt tree): 현재 블록의 거래 영수증 정보 저장

부모 노드는 자식 노드의 해싱값이기 때문에, 단방향 함수인 해시의 특성상 자식 노드의 값이 조금이라도 바뀌면 부모 노드의 값도 바뀌게 됨.
-> 따라서 머클 패트리샤 트리에서 변조가 시도되면 그 즉시 발견됨.

따라서 **루트 노드는 데이터에 대한 보안 ID처럼 사용될 수 있다.**

또한 블록 헤더는 상태, 트랜잭션, 영수증 트리의 루트 노드 값을 가지고 있기 때문에, **네트워크의 노드들은 모든 상태를 저장하고 있지 않더라도 이더리움의 상태 일부분을 검증할 수 있다.**

### 트랜잭션과 메시지
이더리움이 트랜잭션 기반 상태 머신이다.
-> 계정 간에 일어난 트랜잭션은 이더리움의 전역 상태를 하나의 상태에서 다음 상태로 이동시킨다는 것

**기본적으로 트랜잭션은 EOA에서 생성되고,** 일련의 과정을 거쳐 **블록체인에 올라간 "암호화 서명된 명령어의 집합"이다**

그 외의 트랜잭션은 "메시지 호출(message call)"과 "컨트랙트 생성(contract creations)" 두 종류로 나뉨

이더리움의 모든 트랜잭션은 항상 EOA에서 만들어지고 블록체인에 올라감.
즉, 트랜잭션은 외부 세계를 이더리움 내부의 상태로 연결해주는 다리와 같다.
그리고 연결의 창구가 바로 CA인 것

그렇다고 해서 CA가 다른 CA과 전혀 연관 없다는 것은 아님.
이더리움 전역 상태에 있는 CA는 "메시지(message)"나 "내부 트랜잭션(internal transaction)"을 통해 다른 CA와 상호작용 할 수 있다.
**메시지와 내부 트랜잭션은 일반적인 트랜잭션과 비슷하지만, EOA에서 생성되지는 않으며, 오로지 CA에게서만 생성**

한 CA가 다른 CA에 내부 트랜잭션을 보내면, 수신하는 CA에 있는 관련 코드가 실행됨.

### CA 생성

트랜잭션의 두 종류 중 "컨트랙트 생성(contract-creating)" 트랜잭션

새로운 CA를 만들기 위해서는 먼저 특별한 공식을 이용해 새로운 계정의 주소를 정의해야 합니다. 그리고 다음의 과정을 통해 새로운 CA를 만들 수 있다.

1. 논스를 0으로 설정한다.

2. 송신자가 CA 생성 트랜잭션에 이더를 함께 보낸 경우, 이를 CA의 잔금(balance)으로 설정한다.

3. 잔금에서 value 만큼을 제외한다.

4. CA의 스토리지를 빈 값으로 초기화한다.

5. CA의 코드를 빈 문자열의 해시값으로 초기화한다.

한번 계정을 초기화하고 나면, 트랜잭션에서 보낸 init 코드를 사용해 새로운 CA를 생성할 수 있습니다.

이 init 코드가 실행되는 동안에는 다양한 일이 발생합니다. 계약 생성자에 따라 CA의 스토리지를 업데이트하거나, 다른 CA를 새롭게 생성하거나, 다른 메시지 호출을 만들 수 있다.

계약을 초기화하는 이 init 코드를 실행할 때는 가스를 사용합니다. 트랜잭션은 남아있는 가스보다 더 많은 가스를 소비할 수 없기 때문에, 만약 남아있는 가스를 다 사용한 경우 OOG(Out-of-Gas) 예외처리와 함께 코드 실행이 종료

OOG로 인한 트랜잭션 종료가 발생하면 상태는 트랜잭션 실행 이전 상태로 돌아감.

> 트랜잭션을 보낼 때는 코드에 수행되는 만큼의 가스를 함께 보내야 함.

트랜잭션이 실패해도 트랜잭션 송신자는 소진된 가스를 환불받을 수 없습니다. 그러나 송신자가 트랜잭션과 함께 이더 값을 보낸 경우, 이더는 환불됨

init 코드가 성공적으로 실행되면, 마지막으로 CA 코드에 대한 비용이 지불됩니다. 이 비용은 스토리지 비용이며, 생성된 CA 코드의 크기에 비례함.

만약 CA 코드에 대한 비용을 지불할 가스가 남아있지 않은 경우, 트랜잭션은 OOG 예외와 함께 중단됨.

예외 없이 트랜잭션 생성이 완료된 경우, 미사용된 가스는 송신자에게 환불되고, 변경된 상태가 저장됨.

### 메세지 호출
메시지 호출을 실행하는 것은 CA 생성과 비슷하지만, 몇가지 다른 점이 있다.

새 계정이 생성되지 않기 때문에 메시지 호출 실행에는 init 코드가 포함되지 않음.
그러나 입력 데이터를 가지고 있을 수는 있다.

메시지 호출은 한번 실행되면 출력 데이터를 포함한 추가적인 요소들을 가지게 될 수도 있는데, 이 추가 요소들은 뒤에 이어질 다른 실행에 필요한 데이터이다.

CA 생성과 마찬가지로, 메시지 호출을 실행할 때 가스가 부족하거나, 트랜잭션이 잘못되어 종료되는 경우(예를 들어, 스택 오버플로우가 발생하거나, jump 실행의 결과가 올바르지 않거나, 잘못된 명령어를 사용하는 경우) 사용된 가스는 환불되지 않음.

남은 가스는 모두 소비되며, 상태는 직전 상태로 돌아감

### 트랜잭셕 실행 모델과 EVM
트랜잭션은 실제로 EVM에서 동작과정

트랜잭션 처리를 실제로 처리하는 프로토콜은 EVM아다.

#### EVM 구성요소

- 스택
    : EVM은 비트코인 스크립트와 마찬가지로, 스택 기반 아키텍쳐를 가지고 있다.
    EVM 내에는 하나의 빈 스택이 있으며, 스택에 들어가는 요소의 크기는 256bit이며, 스택의 최대 크기는 1024bit

- 메모리
    : EVM은 메모리를 가지고 있으며, 메모리에서는 word-address 형식의 바이트 배열로 데이터를 저장
    메모리는 휘발성이기 때문에, 프로그램이 종료되면 메모리에 들어있는 데이터는 사라짐

- 스토리지
    : 메모리와 다르게, 스토리지는 비휘발성이며 시스템 상태에 따라 유지됩니다. 
    EVM은 특정한 명령어로만 접근할 수 있는 "가상 ROM"이라는 공간에 프로그램 코드를 분리해서 저장

EVM이 솔리디티 코드를 컴파일한 바이트코드를 받으면 실행이 시작된다. 맨 처음에는 메모리와 스택은 비어있으며, 프로그램 카운터(연산 실행 횟수)는 0이다.

```
PC(Program Counter): 0
Stack: []
Memory: []
Storage: {}
```

EVM은 트랜잭션을 반복적으로 실행하며, 각 사이클에서 시스템 상태(이더리움의 전역 상태)와 머신 상태(machine state)를 계산

머신 상태는 다음과 같이 구성됨

- 사용 가능한 가스

- 프로그램 카운터

- 메모리에 들어있는 값

- 메모리에서 활성화된 단어의 수

- 스택에 들어있는 값

코드가 실행되면서 스택에 있는 요소들은 왼쪽에서부터 순서대로 추가되거나 제거되며, 남은 가스에서 적절한 양의 가스가 제거되고, 프로그램 카운터가 올라감.

매 사이클이 끝날 때 다음과 같은 세가지 케이스가 발생할 수 있다.

1. EVM이 예외 상황을 만나 중지되고, 변경사항은 폐기된다. (가스 부족, 명령어가 잘못된 경우, 스택에 잘못된 요소가 들어간 경우, 스택에 있는 요소가 1024 bit를 넘는 경우 등)

2. 다음 사이클을 돌아야 하는 경우

3. 머신이 프로세스 실행을 끝낸 경우

머신이 정상적으로 실행을 마치면, 결과적으로 발생한 상태와 남아있는 가스, 발생한 세부 상태, 결과값을 생성함.

## 스마트 컨트랙트의 실행 비용

이더리움에서 가장 중요한 개념 중 하나는 트랜잭션 실행 수수료.

이더리움에서 트랜잭션의 결과로 발생하는 모든 연산은 수수료를 요구한다. 이 수수료를 가스(gas)라고 함.

가스는 트랜잭션 코드에 있는 모든 opcode를 실행하는데 필요한 수수료를 측정하는 데 사용하는 단위

Gas price은 가스 당 지불하려고 하는 이더의 양을 의미하며, Gwei라는 단위를 사용 (1 이더 = 10^18 wei 이며, 1 Gwei= 10^9 wei)

트랜잭션 송신자는 gas limit과 gas price를 트랜잭션에 지정합니다. 이 gas price와 gas limit은 송신자가 트랜잭션을 실행하는데 지불하고자 하는 Wei의 최대 양을 의미

example)
송신자가 gas limit을 50,000으로 지정하고, gas price를 20 gwei로 지정했다고 가정하자.
이것은 송신자가 최대 50,000 x 20 gwei = 10^15 Wei = 0.001 이더를 트랜잭션을 실행하는 데 지불한다는 것을 의미

gas limit은 송신자가 지불하고자 하는 가스의 최대값을 의미
-> 만약 CA에 이 최대치를 지불하고도 남을 충분한 이더가 들어있다면 트랜잭션은 문제없이 실행될 것

송신자는 트랜잭션이 완료된 후, 사용되지 않은 가스를 기존 비율로 환불받음.
```
Gas limit - use gas(50) - use gas(30) = remaining gas
```

반대로 송신자가 트랜잭션을 실행할만한 충분한 가스를 제공하지 않은 경우, 트랜잭션은 OOG 상태가 되며, 실행이 중지됨.
상태가 변경되었다면, 트랜잭션이 실행되기 이전의 상태로 돌아감.
또한 실패한 트랜잭션에 대한 기록이 남으며, 이 기록에서 어떤 트랜잭션이 시도되었고 어디에서 실패했는지 남게 됨.

그리고 EVM은 트랜잭션 실행이 중지되기 전까지 연산을 수행했기 때문에, 연산에 사용된 가스는 환불되지 않음.

이 가스는 채굴자의 주소로 송금됩니다. 채굴자는 연산을 수행하고 트랜잭션을 검증하는 데에 자원을 소모하기 때문에 이에 대한 보상으로 가스 수수료를 받음.

일반적으로, 송신자가 지불하고자 하는 가스 가격이 높을 수록, 또는 실제 연산에 소요되는 가스의 양이 높을 수록, 채굴자는 트랜잭션에서 수수료를 더 많이 받을 수 있다.

따라서 채굴자들은 수수료를 많이 받을 수 있는 트랜잭션을 선택하려 합니다. 
채굴자들은 트랜잭션 송신자가 gas price를 어느 정도로 설정해야 할지 알려주기 위해 트랜잭션을 실행하거나 검증하는 데 드는 gas price의 최소값을 광고하기도 함.

### 스토리지 수수료
연산을 할 때 뿐만 아니라, 스토리지를 사용할 때도 수수료를 내야 한다. **스토리지의 최종 수수료는 32 바이트 단위에 비례**

스토리지 수수료는 일반적인 수수료와는 다르게 약간 특이한 부분이 있다.
가령, 스토리지가 증가하면 모든 노드에서 이더리움 상태 데이터베이스의 크기가 커지기 때문에 저장되는 데이터의 양을 최대한 적게 유지할 수록 인센티브를 부여함.

이러한 이유 때문에 만약 트랜잭션이 스토리지에 있는 특정 요소를 지우는 연산을 수행하면, 해당 연산을 수행하는 데에 대한 수수료는 면제하고, 
저장 공간을 확보했기 때문에 기존에 요소를 스토리지에 추가했을 때 지불했던 가스를 환불받음.

example)
스토리지에 요소 하나를 할당했을 때 100 gas를 지불해야 한다고 가정
-> 트랜잭션에서 스토리지에 요소 하나를 할당하여 100 gas를 지불
이후 해당 요소를 다시 스토리지에서 제거하는 연산을 수행할 때는, 제거 연산에 대한 수수료는 0 gas이며, 
더이상 스토리지 자리를 차지하지 않기 때문에 할당 할 때 들었던 100 gas를 환불해줌.

### 왜 수수료를 지불해야 할까?
이더리움은 비트코인과는 달리, 스마트 컨트랙트에서 수행되는 모든 연산에 대해 가스라는 수수료를 부과함.

이렇게 수수료를 부과하는 이유는 이더리움 네트워크 위에서 동작하는 스마트 컨트랙트 작업들이 전체 노드에 영향을 미치기 때문이다.

이더리움은 튜링 완전 언어이기 때문에, 튜링 불완전한 비트코인 스크립트와는 달리 반복문을 지원함.

그러나 반복문의 가장 큰 단점은 무한 루프 문제가 일어날 수 있다는 것.

만약 악의적인 사용자가 큰 자원을 소모하는 무한 루프 코드가 들어있는 트랜잭션을 실행시킨다면, 트랜잭션은 이더리움 네트워크의 엄청난 양의 자원을 소모하게 될 것이고, 심각하게는 이더리움 네트워크 전체가 멈출 수도 있다.

수수료는 이러한 악의적인 공격으로부터 네트워크를 보호합니다.

각 연산마다 수수료를 부과하면 악의적인 사용자라도 수수료를 지불해야 하기 때문에 쉽게 무한 루프 코드를 실행시킬 수 없다.

또한 의도치 않게 무한 루프를 만든 코드를 실행시키더라도 gas limit을 설정해두면 지정해둔 가스를 다 소모하기 전에 실행을 멈출 수 있다.


## 스마트 컨트랙트를 활용한 새로운 서비스들

### 금융상품 (DeFi)

탈중앙화 금융(Decentralized Finance)는 스마트 컨트랙트를 활용해 금융 시장, 옵션, 스테이블 코인, 거래소, 자산 관리 등 전통적인 금융 상품과 서비스를 재창조하고,

여러 서비스를 결합하여 새로운 금융 원형을 만들어내는 어플리케이션

스마트 컨트랙트는 사용자의 자금을 에스크로에 보관하고 미리 정해진 조건에 따라 사용자 간에 분배할 수 있도록 함.

예를 들어, Aave는 스마트 컨트랙트를 사용하여 무허가 및 탈중앙화된 방식으로 대출과 차입을 용이하게 함.

### 게임과 NFT

블록체인 기반 게임은 게임 내 액션의 변조 방지를 위해 스마트 컨트랙트를 사용.

한가지 예로, 사용자가 유동성 풀에 자금을 투자한 다음, 이자가 발생하면 금융 시장으로 이동하는 PoolTogether이라는 게임이 있다.

미리 정해진 기간이 지나면 게임이 종료되고 승자에게는 모든 이자가 무작위로 지급되며, 다른 사용자는 예치금을 인출할 수 있다.

마찬가지로, 한정판 NFT는 공정한 배포 모델을 가질 수 있으며, RPG 게임은 무작위성을 사용하여 예측할 수 없는 전리품 드롭을 할 수 있어, 

모든 사용자가 희귀한 디지털 자산을 얻을 수 있는 공정한 기회를 가질 수 있다.

### DAO (Decentralized Autonomous Organization)

DAO는 컴퓨터 프로그램으로 인코딩 되고, 조직 구성원들이 통제하며, 중앙 정부의 영향을 받지 않는 규칙들로 구성된 탈중앙화 자율조직으로, 
영리 및 비영리 기업을 조직하기 위한 새로운 분산형 비즈니스 모델을 제공.

 규칙은 코드에 내장되어 있기 때문에 관리자가 필요하지 않으며, 따라서 관료제나 계층적 구조가 없다.

### ICO (Initial Coin Offering)

ICO는 기업 공개(IPO)와 비슷한 개념으로, 새로운 암호화폐를 만들기 위해 투자자들에게 투자금을 받고, 그 댓가로 코인을 나눠주는 것을 의미

투자자들은 기업이 성공하여 코인에 대한 수요가 증가하여 코인 시세가 오를 것을 기대하고 ICO에 참여

기업은 ICO로 초기 개발 자금을 모아 사업을 성장시켜 코인의 수요를 높이기 위해 노력

### 브릿지(Bridge)

브릿지는 토큰이나 임의의 데이터를 하나의 체인에서 다른 체인으로 전송할 수 있게 하는 연결을 의미.

두 체인은 서로 다른 프로토콜, 규칙, 거버넌스 모델을 가질 수도 있지만, 브릿지는 양 쪽에서 안전하게 상호 운용할 수 있는 호환가능한 방법을 제공

## Web3란?

### Web1, Web2, Web3
Web1은 클라이언트(사용자)가 서버로부터 콘텐츠를 제공받는 것이다.
클라이언트가 정보를 읽기만 할 수 있기 떄문에 Information Economy라고도 불림.

Web2는 AJAX의 등장으로 클라이언트는 서버로부터 단순히 정보를 받기만 하는 것이 아니라, 서버와 상호작용 하면서 서버에 기록(Write)도 할 수 있게 되었다.
인터넷이 정적인 성격에서 동적인 성격으로 변하여 사용자는 정보를 소비할 뿐만 아니라 생성할 수 있게됨.
-> 자신들이 만든 웹 어플리케이션에서 많은 사용자들을 참여시키는 플랫폼 형태의 어플리케이션이 등장

Web2를 대표하는 플랫폼 이코노미에 중요한 문제
-> 구글, 페이스북, 아마존과 같은 소수의 대기업들이 만든 플랫폼을 사용하기 위해 사용자는 자신의 개인정보를 플랫폼에 제공해야함.
기업은 플랫폼을 통해 수많은 사람들의 개인정보를 취하고, 개인 정보를 이용해 광고를 하는 등 수익을 냄.
특정 기업들이 개인정보 보호에 조금이라도 소홀히 다루는 경우, 악의적인 해커에 의해 사용자의 개인정보를 탈취당하는 문제

즉, 사용자의 의도와는 다르게 플랫폼 기업에 의해 개인 정보가 사용되고, 또한 개인 정보에 대한 보안도 각 플랫폼 기업에게 의존해야 하는 문제가 발생

Web3는 이와 같은 Web2의 문제를 해결하기 위해 등장.
중앙집중적인 플랫폼 이코노미를 벗어나, 모든 참여자가 플랫폼이 될 수 있는 분산형 인터넷을 의미하며, 이를 구현하기 위해 블록체인 기술을 기반으로 함.
모든 참여자가 플랫폼이 되기 때문에 모든 데이터가 공유되며, 동시에 암호화 기술을 사용해 개인 정보를 제공하지 않고도 사용자는 신원을 식별할 수 있다.


### Web3의 장점

- 네트워크에 참여하는 누구나 서비스를 사용하기 위한 권한을 가지고 있다. 즉, 그 누구도 허가를 받을 필요가 없다.

- 누구도 특정 사용자가 서비스에 접근하지 못하도록 막거나 거부할 수 없다.

- 결제는 자체 토큰(이더 등)을 사용

- Web2 플랫폼인 트위터나 페이스북은 중앙 집중화 되어 있기 때문에 관리자가 계정이나 게시글을 검열할 수 있지만,

  Web3 기반 dApp은 탈중앙화 되어 있기 때문에 누군가가 게시글을 검열하는 것이 불가능

- Web2 어플리케이션은 중앙 서버가 다운되면 해당 서비스 사용자들이 서비스를 이용하지 못하게 되지만, 

Web3 서버는 수천 대의 노드로 구성된 분산형 네트워크이기 때문에 특정 노드가 죽어도 서비스는 계속 유지

### 중앙 집중화 VS 탈중앙화

네트워크 전송 
    - 중앙 집중화 : 낮은 네트워크 대역폭( 모든 참여자는 중앙기관이 연결되어 있음.) 연산 자원을 많이 가지고 있는 중앙 기관이 전파를 처리
    - 탈중앙화 : 네트워크의 한쪽에서 브로드캐스팅되는 정보는 반대편까지 도달하는 데 오랜 시간이 걸릴 수 있다.

성능 
    - 중앙 집중화 : 비교적 좋은 성능(높은 처리량, 적은 총 컴퓨팅 리소스 사용) - 구현에 용이
    - 탈중앙화 : 비교적 낮은 성능, 구현하기에 복잡

데이터 충돌 해결 
    - 중앙 집중화 : 데이터가 충돌하는 경우, 해결이 쉽고, 간단하다. 중앙 기관이 궁극적인 진실을 가지고 있기 떄문.
    - 탈중앙화 : 만약 참가자가 동기화할 데이터의 상태에 대해 피어가 상반된 주장을 하는 경우, 이러한 갈등 상태를 해결하기 위해 복잡한 프로토콜이 필요하다.

단일 장애 지점 여부 
    - 중앙 집중화 : 단일 장애 지점 -악의적인 공격자가 중앙 기관을 타겟팅 하여 네트워크를 다운시킬 수 있다.
    - 탈중앙화 : 단일 장애 지점 없음. 많은 네트워크 참여자가 공격당해도 네트워크는 여전히 동작할 수 있다.

합의 
    - 중앙 집중화 : 네트워크 참여자들 간의 합의는 중앙 기관이 담당. 중앙 기관은 네트워크 참여자들이 업그레이드와 프로토콜 업데이트를 채택하도록 강제할 수 있다.
    - 탈중앙화 : 단일한 하나의 참여자가 네트워크 수준의 결정이나 프로토콜 업그레이드 등에 최종 결정권을 갖지 못하기 때문에 합의가 매우 어렵다.
                최악의 경우, 프로토콜 변경에 대한 의견 불일치로 인해 네트워크가 파괴되기도 한다.
 
데이터 검열 
    - 중앙 집중화 : 중앙 기관은 네트워크의 일부분을 잘라내어, 나머지 네트워크와 상호작용하는 것을 막는 등, 데이터를 검열할 수 있다.
    - 탈중앙화 : 데이터가 네트워크를 통해 전파되는 경로가 다양하기 때문에 데이터를 검열하는 것은 매우 어렵다.

참여 권한 
    - 중앙 집중화 : 네트워크 참여자는 중앙 기관에 의해 제어된다.
    - 탈중앙화 : 누구나 네트워크에 참여할 수 있으며, 게이트 키퍼는 존재하지 않는다.

## Web3.js란?

이더리움을 사용한 블록체인 어플리케이션을 개발한다는 것
- 솔리디티 언어를 사용해 스마트 컨트랙트를 개발
- 블록체인과 상호작용하는 클라이언트를 개발 의미

Web3.js를 Web3.js는 이더리움 블록체인과 상호 작용하는 클라이언트를 개발하는 데 사용함.

Web3.js는 다른 계정으로 이더를 전송하거나, 스마트 컨트랙트에서 데이터를 읽고 쓰거나, 스마트 컨트랙트를 만드는 등 다양한 액션을 수행할 수 있게 해주는 라이브러리의 집합

### 클라이언트가 이더리움 블록체인과 상호작용하는 방법

#### 구조
Javascript / Java / Python Prgram - Web3 Interface (JSON RPC) - EVM Client <-> Local blockchain copy - Etherum Network

Web.js는 **이더리움 블록체인과 JSON RPC를 사용하여 소통**함. JSON RPC는 "Remote Procedure Call" 프로토콜의 약자.

이더리움은 여러 노드로 구성된 P2P 네트워크이며, 블록체인에 있는 모든 데이터와 코드의 사본을 저장하고 있다.

Web3.js는 **네트워크에 있는 데이터를 읽거나 써야 할 때, JSON RPC를 사용해 하나의 이더리움 노드에게 요청**을 보낸다.

JSON RPC는 우리가 웹 클라이언트에서 웹 서버에게 데이터를 요청하기 위해 XMLHttpRequest를 사용하는 것과 똑같다.

웹에서는 클라이언트가 XMLHttpRequest라는 정해진 형식에 맞춰서 서버에 데이터를 요청함.

마찬가지로 이더리움에서는 클라이언트가 JSON RPC라는 정해진 형식에 맞춰서 이더리움 노드에 데이터를 요청하는 것

Web3.js에는 다음과 같은 다양한 모듈이 있다.

- web3-eth : 이더리움 블록체인과 스마트 컨트랙트 모듈
- web3-shh : P2P 커뮤니케이션과 브로드캐스트를 위한 위스퍼 프토로콜 모듈
- web3-bzz : 탈중앙화 파일 스토리지를 위한 스왐 프로토콜 모듈
- web3-utils : Dapp 개발자를 위한 유용한 헬퍼 함수들을 모아둔 모듈

#### Window.ethereum - 공급자 객체
EIP-1139를 통해, 메타마스크와 같은 지갑 소프트웨어는 웹 페이지에 자바스크립트 객체 형태로 자신의 API를 노출합니다.
이 객체를 공급자(Provider)라고 함.

이전에는 각 지갑 소프트웨어들이 자신의 API를 브라우저에 공급자 객체 형태로 표현
각 지갑마다 공급자 객체를 구현하는 인터페이스나 동작이 조금씩 달랐기 때문에, 브라우저에서 이 공급자 객체들이 충돌하는 문제가 있었다.

\*EIP-1139는 이더리움 공급자 API를 통일하여 지갑 간 상호 운용이 가능하도록 함.

EIP-1139에서 지정한 이더리움 공급자 객체는 브라우저 내에서 window.ethereum으로 지정되어 있다.
